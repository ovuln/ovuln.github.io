<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="http://xvuln.com/WEB%20Guide/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>信息收集 - My Docs</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u4fe1\u606f\u6536\u96c6";
        var mkdocs_page_input_path = "WEB Guide/\u4fe1\u606f\u6536\u96c6.md";
        var mkdocs_page_url = "/WEB%20Guide/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> My Docs
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">WEB 测试指南</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../%E6%A6%82%E8%BF%B0/">概述</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">信息收集</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">利用搜索引擎作信息收集</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">概括</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">测试目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_5">如何测试</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">搜索引擎</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_7">搜索运算符</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">查看缓存内容</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dorking">谷歌黑客，或 Dorking</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_9">整治</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#web-meta">查看Web meta 文件有无敏感信息</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_10">概括</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_11">测试目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_12">如何测试</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_13">机器人</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#google-robotstxt">使用 Google 网站站长工具分析 robots.txt</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_14">元标签</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#meta">机器人 META 标签</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_15">杂项元信息标签</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_16">站点地图</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#txt">安全TXT</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#txt_1">人类 TXT</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_17">其他众所周知的信息来源</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_18">工具</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#web">枚举 Web 服务器上的应用程序</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_19">概括</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_20">测试目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_21">如何测试</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1-url">解决问题 1 的方法 - 非标准 URL</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2-">解决问题 2 的方法 - 非标准端口</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#3-">解决问题 3 的方法 - 虚拟主机</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_24">工具</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_25">审查源码</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_26">概括</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_27">测试目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_28">如何测试</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_29">查看网页评论和元数据</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#javascript-javascript">识别 JavaScript 代码并收集 JavaScript 文件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_30">识别源映射文件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_31">识别泄漏信息的重定向响应</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_32">工具</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_33">参考</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_34">白皮书</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_35">确定应用入口点</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_36">概括</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_37">测试目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_38">如何测试</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_39">要求</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_40">回应</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#owasp">OWASP 攻击面检测器</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_42">测试应用程序入口点</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_43">工具</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_44">参考</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_45">通过应用映射执行路径</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_46">概括</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_47">测试目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_48">如何测试</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_49">自动抓取</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_50">工具</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_51">参考</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#web_1">WEB应用指纹识别</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_52">概括</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_53">测试目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_54">如何测试</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_55">黑盒测试</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_56">特定文件和文件夹</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_59">通用标识符</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cookie_1">Cookie</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#html_1">HTML 源代码</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_62">整治</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_63">工具</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#whatweb">Whatweb</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#wappalyzer">Wappalyzer</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_64">参考</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_65">白皮书</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#web_2">WEB服务器指纹识别</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_66">概括</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_67">测试目标</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_68">如何测试</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#banner">banner 抓取</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_69">发送格式错误的请求</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_70">使用自动扫描工具</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_71">整治</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../2%E3%80%81%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%E7%AE%A1%E7%90%86%E6%B5%8B%E8%AF%95/">配置部署管理测试</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">HTB</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../HTB/HTB-Escape/">Escape</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">DOC</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../DOC/mkdocs/">Mkdocs 文档</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Read</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../../Read/三联生活周刊.md">三联生活周刊</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="https://book.hacktricks.xyz/">Hacktricks</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">My Docs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
          <li>WEB 测试指南 &raquo;</li>
      <li class="breadcrumb-item active">信息收集</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">信息收集</h1>
<h2 id="_2">利用搜索引擎作信息收集</h2>
<p>https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/01-Conduct_Search_Engine_Discovery_Reconnaissance_for_Information_Leakage</p>
<h3 id="_3">概括</h3>
<p>为了让搜索引擎工作，计算机程序（或）定期从网络上的数十亿页面中<code>robots</code>获取数据（称为<a href="https://en.wikipedia.org/wiki/Web_crawler">爬行）。</a>这些程序通过跟踪其他页面的链接或查看站点地图来查找 Web 内容和功能。如果一个网站使用一个特殊的文件<code>robots.txt</code>来列出它不希望搜索引擎获取的页面，那么列出的页面将被忽略。<a href="https://support.google.com/webmasters/answer/70897?hl=en">这是一个基本概述 - Google 对搜索引擎的工作原理</a>提供了更深入的解释。</p>
<p>测试人员可以使用搜索引擎对网站和 Web 应用程序执行侦察。搜索引擎发现和侦察有直接和间接的要素：直接方法涉及从缓存中搜索索引和相关内容，而间接方法涉及通过搜索论坛、新闻组和招标网站来学习敏感的设计和配置信息。</p>
<p>一旦搜索引擎机器人完成爬行，它就会开始根据标签和相关属性（例如 ）对网页内容编制索引<code>&lt;TITLE&gt;</code>，以便返回相关的搜索结果。如果<code>robots.txt</code>文件在网站的生命周期内没有更新，并且没有使用指示机器人不索引内容的内联 HTML 元标记，那么索引可能包含网站不打算包含的内容拥有者。网站所有者可以使用前面提到<code>robots.txt</code>的 HTML 元标记、身份验证和搜索引擎提供的工具来删除此类内容。</p>
<h3 id="_4">测试目标</h3>
<ul>
<li>确定应用程序、系统或组织的哪些敏感设计和配置信息直接（在组织的网站上）或间接（通过第三方服务）公开。</li>
</ul>
<h3 id="_5">如何测试</h3>
<p>使用搜索引擎搜索可能敏感的信息。这可能包括：</p>
<ul>
<li>网络图和配置；</li>
<li>管理员或其他主要员工的存档帖子和电子邮件；</li>
<li>登录程序和用户名格式；</li>
<li>用户名、密码和私钥；</li>
<li>第三方或云服务配置文件；</li>
<li>显示错误信息内容；和</li>
<li>非公共应用程序（开发、测试、用户验收测试 (UAT) 和站点的暂存版本）。</li>
</ul>
<h3 id="_6">搜索引擎</h3>
<p>不要将测试仅限于一个搜索引擎提供商，因为不同的搜索引擎可能会产生不同的结果。搜索引擎结果可能会在几个方面有所不同，具体取决于引擎上次抓取内容的时间，以及引擎用来确定相关页面的算法。考虑使用以下（按字母顺序列出的）搜索引擎：</p>
<ul>
<li><a href="https://www.baidu.com/">百度</a>，中国<a href="https://en.wikipedia.org/wiki/Web_search_engine#Market_share">最受欢迎</a>的搜索引擎。</li>
<li><a href="https://www.bing.com/">Bing</a>是微软拥有和运营的搜索引擎，全球第二<a href="https://en.wikipedia.org/wiki/Web_search_engine#Market_share">受欢迎</a>。支持<a href="http://help.bing.microsoft.com/#apex/18/en-US/10001/-1">高级搜索关键字</a>。</li>
<li><a href="https://binsearch.info/">binsearch.info</a>，二进制 Usenet 新闻组的搜索引擎。</li>
<li><a href="https://commoncrawl.org/">Common Crawl</a>，“任何人都可以访问和分析的网络爬虫数据的开放存储库。”</li>
<li><a href="https://duckduckgo.com/">DuckDuckGo</a>是一个以隐私为中心的搜索引擎，可以从许多不同的<a href="https://help.duckduckgo.com/results/sources/">来源</a>编译结果。支持<a href="https://help.duckduckgo.com/duckduckgo-help-pages/results/syntax/">搜索语法</a>。</li>
<li><a href="https://www.google.com/">Google</a>提供世界上<a href="https://en.wikipedia.org/wiki/Web_search_engine#Market_share">最受欢迎</a>的搜索引擎，并使用排名系统尝试返回最相关的结果。支持<a href="https://support.google.com/websearch/answer/2466433">搜索运算符</a>。</li>
<li><a href="https://archive.org/web/">Internet Archive Wayback Machine</a>，“以数字形式构建互联网站点和其他文化制品的数字图书馆。”</li>
<li><a href="https://www.shodan.io/">Shodan</a>，一种用于搜索联网设备和服务的服务。使用选项包括有限的免费计划以及付费订阅计划。</li>
</ul>
<h3 id="_7">搜索运算符</h3>
<p>搜索运算符是一种特殊的关键字或语法，可扩展常规搜索查询的功能，并有助于获得更具体的结果。它们通常采用<code>operator:query</code>. 以下是一些通常支持的搜索运算符：</p>
<ul>
<li><code>site:</code>将搜索限制在提供的域中。</li>
<li><code>inurl:</code>将只返回在 URL 中包含关键字的结果。</li>
<li><code>intitle:</code>只会返回页面标题中包含关键字的结果。</li>
<li><code>intext:</code>或者<code>inbody:</code>只会在页面正文中搜索关键字。</li>
<li><code>filetype:</code>将仅匹配特定文件类型，即<code>.png</code>, 或<code>.php</code>.</li>
</ul>
<p>例如，要查找由典型搜索引擎索引的 owasp.org 的 Web 内容，所需语法为：</p>
<pre><code>site:owasp.org
</code></pre>
<p><img alt="Google 站点操作搜索结果示例" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/Google_site_Operator_Search_Results_Example_20200406.png" /><br />
<em>图 4.1.1-1：Google 站点操作搜索结果示例</em></p>
<h3 id="_8">查看缓存内容</h3>
<p>要搜索以前已编入索引的内容，请使用<code>cache:</code>运算符。这有助于查看自索引以来可能已更改的内容，或者可能不再可用的内容。并非所有搜索引擎都提供缓存内容进行搜索；在撰写本文时最有用的来源是谷歌。</p>
<p>要<code>owasp.org</code>在缓存时查看，语法为：</p>
<pre><code>cache:owasp.org
</code></pre>
<p><img alt="谷歌缓存操作搜索结果示例" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/Google_cache_Operator_Search_Results_Example_20200406.png" /><br />
<em>图 4.1.1-2：谷歌缓存操作搜索结果示例</em></p>
<h3 id="dorking">谷歌黑客，或 Dorking</h3>
<p>当与测试人员的创造力相结合时，使用运算符进行搜索可能是一种非常有效的发现技术。可以链接运算符以有效地发现特定种类的敏感文件和信息。这种称为<a href="https://en.wikipedia.org/wiki/Google_hacking">Google hacking</a>或 Dorking 的技术也可以使用其他搜索引擎，只要支持搜索运算符。</p>
<p>诸如<a href="https://www.exploit-db.com/google-hacking-database">Google Hacking Database</a>之类的 dorks 数据库是一种有用的资源，可以帮助发现特定信息。该数据库中可用的一些类别的 dorks 包括：</p>
<ul>
<li>立足点</li>
<li>包含用户名的文件</li>
<li>敏感目录</li>
<li>Web 服务器检测</li>
<li>易受攻击的文件</li>
<li>易受攻击的服务器</li>
<li>错误信息</li>
<li>包含多汁信息的文件</li>
<li>包含密码的文件</li>
<li>敏感的在线购物信息</li>
</ul>
<h3 id="_9">整治</h3>
<p>在将设计和配置信息发布到网上之前，请仔细考虑其敏感性。</p>
<p>定期审查在线发布的现有设计和配置信息的敏感性。
https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/03-Review_Webserver_Metafiles_for_Information_Leakage</p>
<h2 id="web-meta">查看Web meta 文件有无敏感信息</h2>
<h3 id="_10">概括</h3>
<p>本节介绍如何测试各种元数据文件是否存在 Web 应用程序路径或功能的信息泄漏。此外，蜘蛛、机器人或爬虫要避免的目录列表也可以创建为<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/07-Map_Execution_Paths_Through_Application">通过应用程序映射执行路径</a>的依赖项。还可以收集其他信息以识别攻击面、技术细节或用于社会工程参与。</p>
<h3 id="_11">测试目标</h3>
<ul>
<li>通过分析元数据文件识别隐藏或混淆的路径和功能。</li>
<li>提取并映射可能导致更好地了解手头系统的其他信息。</li>
</ul>
<h3 id="_12">如何测试</h3>
<blockquote>
<p>下面用 执行的任何操作<code>wget</code>也可以用 完成<code>curl</code>。许多动态应用程序安全测试 (DAST) 工具（例如 ZAP 和 Burp Suite）都包含对这些资源的检查或解析，作为其蜘蛛/爬虫功能的一部分。还可以使用各种<a href="https://en.wikipedia.org/wiki/Google_hacking">Google Dorks</a>或利用诸如<code>inurl:</code>.</p>
</blockquote>
<h4 id="_13">机器人</h4>
<p>Web Spiders、Robots 或 Crawlers 检索网页，然后递归遍历超链接以检索更多的 Web 内容。它们可接受的行为由Web 根目录中的<a href="https://www.robotstxt.org/">robots.txt文件的</a><a href="https://www.robotstxt.org/">机器人排除协议指定。</a><a href="https://www.robotstxt.org/"></a></p>
<p>例如，下面引用了 2020 年 5 月 5 日从<a href="https://www.google.com/robots.txt">Google</a><code>robots.txt</code>采样的文件的开头：<a href="https://www.google.com/robots.txt"></a></p>
<pre><code>User-agent: *
Disallow: /search
Allow: /search/about
Allow: /search/static
Allow: /search/howsearchworks
Disallow: /sdch
...
</code></pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent">User-Agent</a>指令是指特定的网络蜘蛛/机器人/爬虫。例如，<code>User-Agent: Googlebot</code>指的是来自谷歌的蜘蛛，而<code>User-Agent: bingbot</code>指的是来自微软的爬虫。<code>User-Agent: *</code>在上面的例子中适用于所有<a href="https://support.google.com/webmasters/answer/6062608?visit_id=637173940975499736-3548411022&amp;rd=1">网络蜘蛛/机器人/爬虫</a>。</p>
<p>该<code>Disallow</code>指令指定哪些资源被蜘蛛/机器人/爬虫禁止。在上面的示例中，禁止以下内容：</p>
<pre><code>...
Disallow: /search
...
Disallow: /sdch
...
</code></pre>
<p>网络蜘蛛/机器人/爬虫可以<a href="https://blog.isc2.org/isc2_blog/2008/07/the-attack-of-t.html">故意忽略</a><code>Disallow</code>文件中指定的指令<code>robots.txt</code>。因此，<code>robots.txt</code>不应将其视为对第三方访问、存储或重新发布 Web 内容的方式实施限制的机制。</p>
<p>该<code>robots.txt</code>文件是从 Web 服务器的 Web 根目录中检索的。例如，要使用or检索<code>robots.txt</code>from ：<code>www.google.com``wget``curl</code></p>
<pre><code>$ curl -O -Ss http://www.google.com/robots.txt &amp;&amp; head -n5 robots.txt
User-agent: *
Disallow: /search
Allow: /search/about
Allow: /search/static
Allow: /search/howsearchworks
...
</code></pre>
<h4 id="google-robotstxt">使用 Google 网站站长工具分析 robots.txt</h4>
<p>网站所有者可以使用 Google 的“Analyze robots.txt”功能来分析网站，作为其<a href="https://www.google.com/webmasters/tools">Google 网站管理员工具</a>的一部分。该工具可以辅助测试，流程如下：</p>
<ol>
<li>使用 Google 帐户登录 Google 网站站长工具。</li>
<li>在仪表板上，输入要分析的站点的 URL。</li>
<li>在可用方法之间进行选择，然后按照屏幕上的说明进行操作。</li>
</ol>
<h3 id="_14">元标签</h3>
<p><code>&lt;META&gt;</code>标记位于<code>HEAD</code>每个 HTML 文档的部分内，并且在机器人/蜘蛛/爬虫起点不是从 webroot 以外的文档链接（即<a href="https://en.wikipedia.org/wiki/Deep_linking">深层链接</a>）开始的情况下，应该在整个网站上保持一致。Robots 指令也可以通过使用特定的<a href="https://www.robotstxt.org/meta.html">META 标记</a>来指定。</p>
<h4 id="meta">机器人 META 标签</h4>
<p>如果没有<code>&lt;META NAME="ROBOTS" ... &gt;</code>条目，则“机器人排除协议”默认为<code>INDEX,FOLLOW</code>分别。因此，“机器人排除协议”定义的另外两个有效条目以<code>NO...</code>ie<code>NOINDEX</code>和为前缀<code>NOFOLLOW</code>。</p>
<p>根据 webroot 文件中列出的 Disallow 指令，在每个网页中进行<code>robots.txt</code>正则表达式搜索，并将结果与​​ webroot 中的文件进行比较。<code>&lt;META NAME="ROBOTS"``robots.txt</code></p>
<h4 id="_15">杂项元信息标签</h4>
<p>组织经常在 Web 内容中嵌入信息 META 标签以支持各种技术，例如屏幕阅读器、社交网络预览、搜索引擎索引等。此类元信息对于测试人员识别所使用的技术以及要探索的其他路径/功能可能很有价值和测试。以下元信息是<code>www.whitehouse.gov</code>在 2020 年 5 月 5 日通过查看页面源检索到的：</p>
<pre><code>...
&lt;meta property=&quot;og:locale&quot; content=&quot;en_US&quot; /&gt;
&lt;meta property=&quot;og:type&quot; content=&quot;website&quot; /&gt;
&lt;meta property=&quot;og:title&quot; content=&quot;The White House&quot; /&gt;
&lt;meta property=&quot;og:description&quot; content=&quot;We, the citizens of America, are now joined in a great national effort to rebuild our country and to restore its promise for all. – President Donald Trump.&quot; /&gt;
&lt;meta property=&quot;og:url&quot; content=&quot;https://www.whitehouse.gov/&quot; /&gt;
&lt;meta property=&quot;og:site_name&quot; content=&quot;The White House&quot; /&gt;
&lt;meta property=&quot;fb:app_id&quot; content=&quot;1790466490985150&quot; /&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://www.whitehouse.gov/wp-content/uploads/2017/12/wh.gov-share-img_03-1024x538.png&quot; /&gt;
&lt;meta property=&quot;og:image:secure_url&quot; content=&quot;https://www.whitehouse.gov/wp-content/uploads/2017/12/wh.gov-share-img_03-1024x538.png&quot; /&gt;
&lt;meta name=&quot;twitter:card&quot; content=&quot;summary_large_image&quot; /&gt;
&lt;meta name=&quot;twitter:description&quot; content=&quot;We, the citizens of America, are now joined in a great national effort to rebuild our country and to restore its promise for all. – President Donald Trump.&quot; /&gt;
&lt;meta name=&quot;twitter:title&quot; content=&quot;The White House&quot; /&gt;
&lt;meta name=&quot;twitter:site&quot; content=&quot;@whitehouse&quot; /&gt;
&lt;meta name=&quot;twitter:image&quot; content=&quot;https://www.whitehouse.gov/wp-content/uploads/2017/12/wh.gov-share-img_03-1024x538.png&quot; /&gt;
&lt;meta name=&quot;twitter:creator&quot; content=&quot;@whitehouse&quot; /&gt;
...
&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;The White House&quot;&gt;
&lt;meta name=&quot;application-name&quot; content=&quot;The White House&quot;&gt;
&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#0c2644&quot;&gt;
&lt;meta name=&quot;theme-color&quot; content=&quot;#f5f5f5&quot;&gt;
...
</code></pre>
<h3 id="_16">站点地图</h3>
<p>站点地图是一个文件，开发人员或组织可以在其中提供有关站点或应用程序提供的页面、视频和其他文件的信息，以及它们之间的关系。搜索引擎可以使用此文件更智能地探索您的网站。测试人员可以使用<code>sitemap.xml</code>文件来了解有关站点或应用程序的更多信息，从而更全面地探索它。</p>
<p>以下摘录自 2020 年 5 月 5 日检索到的 Google 主要站点地图。</p>
<pre><code>$ wget --no-verbose https://www.google.com/sitemap.xml &amp;&amp; head -n8 sitemap.xml
2020-05-05 12:23:30 URL:https://www.google.com/sitemap.xml [2049] -&gt; &quot;sitemap.xml&quot; [1]

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;sitemapindex xmlns=&quot;http://www.google.com/schemas/sitemap/0.84&quot;&gt;
  &lt;sitemap&gt;
    &lt;loc&gt;https://www.google.com/gmail/sitemap.xml&lt;/loc&gt;
  &lt;/sitemap&gt;
  &lt;sitemap&gt;
    &lt;loc&gt;https://www.google.com/forms/sitemaps.xml&lt;/loc&gt;
  &lt;/sitemap&gt;
...
</code></pre>
<p>测试人员可能希望从那里探索以检索 gmail 站点地图<code>https://www.google.com/gmail/sitemap.xml</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot; xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
  &lt;url&gt;
    &lt;loc&gt;https://www.google.com/intl/am/gmail/about/&lt;/loc&gt;
    &lt;xhtml:link href=&quot;https://www.google.com/gmail/about/&quot; hreflang=&quot;x-default&quot; rel=&quot;alternate&quot;/&gt;
    &lt;xhtml:link href=&quot;https://www.google.com/intl/el/gmail/about/&quot; hreflang=&quot;el&quot; rel=&quot;alternate&quot;/&gt;
    &lt;xhtml:link href=&quot;https://www.google.com/intl/it/gmail/about/&quot; hreflang=&quot;it&quot; rel=&quot;alternate&quot;/&gt;
    &lt;xhtml:link href=&quot;https://www.google.com/intl/ar/gmail/about/&quot; hreflang=&quot;ar&quot; rel=&quot;alternate&quot;/&gt;
...
</code></pre>
<h3 id="txt">安全TXT</h3>
<p><a href="https://securitytxt.org/">security.txt</a>被 IETF 批准为<a href="https://www.rfc-editor.org/rfc/rfc9116.html">RFC 9116 - 一种有助于安全漏洞披露的文件格式</a>，允许网站定义安全策略和联系方式。有多种原因可能对测试场景感兴趣，包括但不限于：</p>
<ul>
<li>识别进一步的路径或资源以包含在发现/分析中。</li>
<li>开源情报收集。</li>
<li>查找有关 Bug Bounties 等的信息。</li>
<li>社会工程学。</li>
</ul>
<p>该文件可能存在于网络服务器的根目录中或<code>.well-known/</code>目录中。前任：</p>
<ul>
<li><code>https://example.com/security.txt</code></li>
<li><code>https://example.com/.well-known/security.txt</code></li>
</ul>
<p>这是从 LinkedIn 2020 年 5 月 5 日检索到的真实示例：</p>
<pre><code>$ wget --no-verbose https://www.linkedin.com/.well-known/security.txt &amp;&amp; cat security.txt
2020-05-07 12:56:51 URL:https://www.linkedin.com/.well-known/security.txt [333/333] -&gt; &quot;security.txt&quot; [1]
# Conforms to IETF `draft-foudil-securitytxt-07`
Contact: mailto:security@linkedin.com
Contact: https://www.linkedin.com/help/linkedin/answer/62924
Encryption: https://www.linkedin.com/help/linkedin/answer/79676
Canonical: https://www.linkedin.com/.well-known/security.txt
Policy: https://www.linkedin.com/help/linkedin/answer/62924
</code></pre>
<h3 id="txt_1">人类 TXT</h3>
<p><code>humans.txt</code>是一个了解网站背后的人的倡议。它采用文本文件的形式，其中包含有关为构建网站做出贡献的不同人员的信息。该文件通常（但不总是）包含有关职业或工作地点/路径的信息。</p>
<p>以下示例检索自 Google 2020 年 5 月 5 日：</p>
<pre><code>$ wget --no-verbose  https://www.google.com/humans.txt &amp;&amp; cat humans.txt
2020-05-07 12:57:52 URL:https://www.google.com/humans.txt [286/286] -&gt; &quot;humans.txt&quot; [1]
Google is built by a large team of engineers, designers, researchers, robots, and others in many different sites across the globe. It is updated continuously, and built with more tools and technologies than we can shake a stick at. If you'd like to help us out, see careers.google.com.
</code></pre>
<h3 id="_17">其他众所周知的信息来源</h3>
<p>还有其他 RFC 和 Internet 草案建议在<code>.well-known/</code>目录中对文件进行标准化使用。可以在<a href="https://en.wikipedia.org/wiki/List_of_/.well-known/_services_offered_by_webservers">此处</a>或<a href="https://www.iana.org/assignments/well-known-uris/well-known-uris.xhtml">此处</a>找到其中的列表。</p>
<p>测试人员查看 RFC/草稿并创建一个列表以提供给爬虫或模糊器，以验证此类文件的存在或内容，这将是相当简单的。</p>
<h3 id="_18">工具</h3>
<ul>
<li>浏览器（查看源代码或开发工具功能）</li>
<li>卷曲</li>
<li>wget</li>
<li>打嗝套件</li>
<li>ZAP</li>
</ul>
<h2 id="web">枚举 Web 服务器上的应用程序</h2>
<p>https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/04-Enumerate_Applications_on_Webserver</p>
<h3 id="_19">概括</h3>
<p>测试 Web 应用程序漏洞的最重要步骤是找出 Web 服务器上托管了哪些特定应用程序。许多应用程序都有已知的漏洞和已知的攻击策略，可以利用这些漏洞和攻击策略来获得远程控制或利用数据。此外，许多应用程序经常配置错误或未更新，因为人们认为它们仅在“内​​部”使用，因此不存在威胁​​。随着虚拟 Web 服务器的激增，IP 地址和 Web 服务器之间传统的 1:1 关系正在失去其原有的大部分意义。多个网站或应用程序的符号名称解析为同一 IP 地址的情况并不少见。这种场景不仅限于托管环境，也适用于普通的企业环境。</p>
<p>安全专业人员有时会获得一组 IP 地址作为测试目标。有争议的是，此场景更类似于渗透测试类型的参与，但无论如何，预计此类任务将测试可通过此目标访问的所有 Web 应用程序。问题是给定的 IP 地址在端口 80 上托管 HTTP 服务，但是如果测试人员应该通过指定 IP 地址（这是他们所知道的）访问它，它会报告“此地址未配置 Web 服务器”或类似消息. 但是该系统可以“隐藏”许多与不相关的符号 (DNS) 名称关联的 Web 应用程序。显然，分析的范围深受测试人员测试所有应用程序或只测试他们知道的应用程序的影响。</p>
<p>有时，目标规范更丰富。测试人员可能会得到一个 IP 地址列表及其相应的符号名称。然而，这个列表可能传达了部分信息，即它可能省略了一些符号名称，而客户甚至可能没有意识到这一点（这在大型组织中更有可能发生）。</p>
<p>影响评估范围的其他问题由在非明显 URL（例如，<code>http://www.example.com/some-strange-URL</code>）上发布的 Web 应用程序表示，这些 URL 未在其他地方引用。这可能是由于错误（由于配置错误）或有意（例如，未公布的管理界面）造成的。</p>
<p>为了解决这些问题，有必要执行 Web 应用程序发现。</p>
<h3 id="_20">测试目标</h3>
<ul>
<li>枚举范围内存在于 Web 服务器上的应用程序。</li>
</ul>
<h3 id="_21">如何测试</h3>
<p>Web 应用程序发现是一个旨在识别给定基础架构上的 Web 应用程序的过程。后者通常指定为一组 IP 地址（可能是一个网络块），但也可能包含一组 DNS 符号名称或两者的混合。这些信息在评估执行之前分发，无论是经典风格的渗透测试还是以应用程序为中心的评估。在这两种情况下，除非参与规则另有规定（例如，仅测试位于 URL 的应用程序<code>http://www.example.com/</code>），否则评估应力求范围最全面，即它应识别可通过给定目标访问的所有应用程序。以下示例检查了可用于实现此目标的一些技术。</p>
<blockquote>
<p>以下一些技术适用于面向 Internet 的 Web 服务器，即 DNS 和反向 IP 基于 Web 的搜索服务以及搜索引擎的使用。示例使用私有 IP 地址（例如<code>192.168.1.100</code>），除非另有说明，否则代表_通用_IP 地址并且仅用于匿名目的。</p>
</blockquote>
<p>影响有多少应用程序与给定 DNS 名称（或 IP 地址）相关的三个因素：</p>
<ol>
<li>
<p><strong>不同的基本 URL</strong></p>
<p>Web 应用程序的明显入口点是<code>www.example.com</code>，即，使用这种简写符号，我们认为 Web 应用程序起源于<code>http://www.example.com/</code>（这同样适用于 HTTPS）。然而，即使这是最常见的情况，也没有强制应用程序从<code>/</code>.</p>
<p>例如，相同的符号名称可能与三个 Web 应用程序相关联，例如：<code>http://www.example.com/url1</code> <code>http://www.example.com/url2</code> <code>http://www.example.com/url3</code></p>
<p>在这种情况下，URL<code>http://www.example.com/</code>不会与有意义的页面相关联，并且这三个应用程序将被<strong>隐藏</strong>，除非测试人员明确知道如何访问它们，即测试人员知道_url1_、<em>url2_或_url3</em>。通常不需要以这种方式发布 Web 应用程序，除非所有者不希望以标准方式访问它们，并且准备告知用户其确切位置。这并不意味着这些应用程序是秘密的，只是它们的存在和位置没有被明确公布。</p>
</li>
<li>
<p><strong>非标准端口</strong></p>
<p>虽然 Web 应用程序通常位于端口 80 (HTTP) 和 443 (HTTPS) 上，但这些端口号并没有什么神奇之处。事实上，Web 应用程序可能与任意 TCP 端口相关联，并且可以通过指定端口号来引用，如下所示：<code>http[s]://www.example.com:port/</code>. 例如，<code>http://www.example.com:20000/</code>。</p>
</li>
<li>
<p><strong>虚拟主机</strong></p>
<p>DNS 允许单个 IP 地址与一个或多个符号名称相关联。例如，IP 地址<code>192.168.1.100</code>可能与 DNS 名称<code>www.example.com</code>、<code>helpdesk.example.com</code>、相关联<code>webmail.example.com</code>。不必所有名称都属于同一个 DNS 域。这种 1 对 N 的关系可以反映为通过使用所谓的虚拟主机来提供不同的内容。我们所指的指定虚拟主机的信息嵌入在 HTTP 1.1<a href="https://tools.ietf.org/html/rfc2616#section-14.23">主机标头</a>中。</p>
<p>人们不会怀疑除了显而易见的之外还有其他 Web 应用程序的存在<code>www.example.com</code>，除非他们知道<code>helpdesk.example.com</code>和<code>webmail.example.com</code>。</p>
</li>
</ol>
<h4 id="1-url">解决问题 1 的方法 - 非标准 URL</h4>
<p>没有办法完全确定是否存在非标准命名的 Web 应用程序。由于是非标准的，因此没有管理命名约定的固定标准，但是测试人员可以使用多种技术来获得一些额外的洞察力。</p>
<p>首先，如果 Web 服务器配置错误并允许目录浏览，则可能会发现这些应用程序。漏洞扫描器可能在这方面有所帮助。</p>
<p>其次，这些应用程序可能会被其他网页引用，并且有可能被网络搜索引擎抓取和索引。如果测试人员怀疑此类<strong>隐藏</strong>应用程序的存在，<code>www.example.com</code>他们可以使用_网站_运营商进行搜索并检查查询结果<code>site: www.example.com</code>。在返回的 URL 中，可能有一个指向这样一个不明显的应用程序。</p>
<p>另一种选择是探测可能是未发布应用程序候选者的 URL。例如，可以从 <code>https://www.example.com/webmail</code>、<code>https://webmail.example.com/</code> 或 <code>https://mail.example.com/</code>等 URL 访问 Web邮件前端。这同样适用于管理界面，它们可以在隐藏的 URL 上发布（例如，Tomcat 管理界面），但不会在任何地方引用。因此，进行一些字典式搜索（或“智能猜测”）可能会产生一些结果。漏洞扫描器可能在这方面有所帮助。</p>
<h4 id="2-">解决问题 2 的方法 - 非标准端口</h4>
<p>很容易检查非标准端口上是否存在 Web 应用程序。Nmap等端口扫描器可以通过<code>-sV</code>选项进行服务识别，识别任意端口上的http[s]服务。所需要的是对整个 64k TCP 端口地址空间的全面扫描。</p>
<p>例如，以下命令将通过 TCP 连接扫描查找 IP 上所有打开的端口，<code>192.168.1.100</code>并尝试确定哪些服务绑定到它们（仅显示_必要_的开关 - Nmap 具有广泛的选项集，其讨论是超出范围）：</p>
<p><code>nmap –Pn –sT –sV –p0-65535 192.168.1.100</code></p>
<p>检查输出并查找 HTTP 或 TLS 包装服务的指示（应探测以确认它们是 HTTPS）就足够了。例如，上一个命令的输出可能如下所示：</p>
<pre><code>Interesting ports on 192.168.1.100:
(The 65527 ports scanned but not shown below are in state: closed)
PORT      STATE SERVICE     VERSION
22/tcp    open  ssh         OpenSSH 3.5p1 (protocol 1.99)
80/tcp    open  http        Apache httpd 2.0.40 ((Red Hat Linux))
443/tcp   open  ssl         OpenSSL
901/tcp   open  http        Samba SWAT administration server
1241/tcp  open  ssl         Nessus security scanner
3690/tcp  open  unknown
8000/tcp  open  http-alt?
8080/tcp  open  http        Apache Tomcat/Coyote JSP engine 1.1
</code></pre>
<p>从这个例子中，可以看出：</p>
<ul>
<li>有一个 Apache HTTP 服务器在端口 80 上运行。</li>
<li>443端口好像有HTTPS服务器（不过这个需要确认，比如<code>https://192.168.1.100</code>用浏览器访问）。</li>
<li>在端口 901 上有一个 Samba SWAT Web 界面。</li>
<li>端口 1241 上的服务不是 HTTPS，而是 TLS 封装的 Nessus 守护进程。</li>
<li>端口 3690 具有未指定的服务（Nmap 返回其_指纹_- 此处为清楚起见省略 - 以及将其提交并纳入 Nmap 指纹数据库的说明，前提是您知道它代表的服务）。</li>
<li>端口 8000 上的另一个未指定服务；这可能是 HTTP，因为在此端口上找到 HTTP 服务器并不罕见。让我们检查一下这个问题：</li>
</ul>
<pre><code>$ telnet 192.168.10.100 8000
Trying 192.168.1.100...
Connected to 192.168.1.100.
Escape character is '^]'.
GET / HTTP/1.0

HTTP/1.0 200 OK
pragma: no-cache
Content-Type: text/html
Server: MX4J-HTTPD/1.0
expires: now
Cache-Control: no-cache

&lt;html&gt;
...
</code></pre>
<p>这证实它实际上是一个 HTTP 服务器。或者，测试人员可以使用网络浏览器访问该 URL；或使用 GET 或 HEAD Perl 命令，它们模仿 HTTP 交互，例如上面给出的交互（但是 HEAD 请求可能不会被所有服务器接受）。</p>
<ul>
<li>Apache Tomcat 在端口 8080 上运行。</li>
</ul>
<p>漏洞扫描器可能会执行相同的任务，但首先检查所选扫描器是否能够识别在非标准端口上运行的 HTTP[S] 服务。例如，Nessus 能够在任意端口上识别它们（前提是它被指示扫描所有端口），并且将提供关于 Nmap 的大量针对已知 Web 服务器漏洞的测试，以及 TLS/ HTTPS 服务的 SSL 配置。如前所述，Nessus 还能够发现流行的应用程序或 web 界面，否则可能会被忽视（例如，Tomcat 管理界面）。</p>
<h4 id="3-">解决问题 3 的方法 - 虚拟主机</h4>
<p>有许多技术可用于识别与给定 IP 地址关联的 DNS 名称<code>x.y.z.t</code>。</p>
<h5 id="dns">DNS 区域传输</h5>
<p>考虑到 DNS 服务器基本上不支持区域传输这一事实，这种技术现在的使用受到限制。但是，这可能值得一试。首先，测试人员必须确定服务于<code>x.y.z.t</code>. 如果一个符号名称已知<code>x.y.z.t</code>（假设为），则可以通过、或等工具通过请求 DNS NS 记录<code>www.example.com</code>来确定其名称服务器。<code>nslookup``host``dig</code></p>
<p>如果没有已知的符号名称<code>x.y.z.t</code>，但目标定义至少包含一个符号名称，测试人员可能会尝试应用相同的过程并查询该名称的名称服务器（希望该名称服务器<code>x.y.z.t</code>也能提供服务）。例如，如果目标由 IP 地址<code>x.y.z.t</code>和名称组成<code>mail.example.com</code>，则确定域的名称服务器<code>example.com</code>。</p>
<p>以下示例显示如何<code>www.owasp.org</code>使用以下<code>host</code>命令识别名称服务器：</p>
<pre><code>$ host -t ns www.owasp.org
www.owasp.org is an alias for owasp.org.
owasp.org name server ns1.secure.net.
owasp.org name server ns2.secure.net.
</code></pre>
<p>现在可以向域的名称服务器请求区域传输<code>example.com</code>。如果测试人员幸运的话，他们将得到该域的 DNS 条目列表。这将包括明显<code>www.example.com</code>的和不太明显的<code>helpdesk.example.com</code>以及<code>webmail.example.com</code>（可能还有其他）。检查区域传输返回的所有名称，并考虑所有与正在评估的目标相关的名称。</p>
<p>尝试<code>owasp.org</code>从其名称服务器之一请求区域传输：</p>
<pre><code>$ host -l www.owasp.org ns1.secure.net
Using domain server:
Name: ns1.secure.net
Address: 192.220.124.10#53
Aliases:

Host www.owasp.org not found: 5(REFUSED)
; Transfer failed.
</code></pre>
<h5 id="dns_1">DNS 反向查询</h5>
<p>此过程与前一个过程类似，但依赖于反向 (PTR) DNS 记录。不要请求区域传输，而是尝试将记录类型设置为 PTR 并在给定的 IP 地址上发出查询。如果测试人员幸运的话，他们可能会得到一个 DNS 名称条目。此技术依赖于 IP 到符号名称映射的存在，但不能保证这一点。</p>
<h5 id="web-dns">基于 Web 的 DNS 搜索</h5>
<p>这种搜索类似于 DNS 区域传输，但依赖于在 DNS 上启用基于名称的搜索的基于 Web 的服务。其中一项服务是<a href="https://searchdns.netcraft.com/?host">Netcraft 搜索 DNS</a>服务。测试人员可能会查询属于您选择的域的名称列表，例如<code>example.com</code>. 然后他们将检查他们获得的名称是否与他们正在检查的目标相关。</p>
<h5 id="ip">反向 IP 服务</h5>
<p>反向 IP 服务类似于 DNS 反向查询，不同之处在于测试人员查询基于 Web 的应用程序而不是名称服务器。有许多这样的服务可用。由于它们倾向于返回部分（并且通常是不同的）结果，因此最好使用多种服务来获得更全面的分析。</p>
<ul>
<li><a href="https://mxtoolbox.com/ReverseLookup.aspx">MxToolbox 反向 IP</a></li>
<li><a href="https://www.dnsstuff.com/">DNSstuff</a>（提供多种服务）</li>
<li><a href="https://web.archive.org/web/20190515092354/http://www.net-square.com/mspawn.html">Net Square</a>（域名和IP地址的多次查询，需要安装）</li>
</ul>
<h5 id="_22">谷歌搜索</h5>
<p>从以前的技术收集信息后，测试人员可以依靠搜索引擎来改进和增加他们的分析。这可能会产生属于目标的其他符号名称的证据，或者可以通过不明显的 URL 访问的应用程序。</p>
<p>例如，考虑前面关于 的示例<code>www.owasp.org</code>，测试人员可以查询 Google 和其他搜索引擎以查找与新发现的域 、 和 相关的信息（因此，DNS<code>webgoat.org</code>名称<code>webscarab.com</code>）<code>webscarab.net</code>。</p>
<p>谷歌搜索技术在<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/01-Conduct_Search_Engine_Discovery_Reconnaissance_for_Information_Leakage">测试：蜘蛛、机器人和爬虫</a>中有解释。</p>
<h5 id="_23">数字证书</h5>
<p>如果服务器接受通过 HTTPS 的连接，则证书上的通用名称 (CN) 和主题备用名称 (SAN) 可能包含一个或多个主机名。但是，如果网络服务器没有受信任的证书，或者正在使用通配符，则可能不会返回任何有效信息。</p>
<p>CN和SAN可以通过手动查看证书获取，也可以通过OpenSSL等其他工具获取：</p>
<pre><code>openssl s_client -connect 93.184.216.34:443 &lt;/dev/null 2&gt;/dev/null | openssl x509 -noout -text | grep -E 'DNS:|Subject:'

Subject: C = US, ST = California, L = Los Angeles, O = Internet Corporation for Assigned Names and Numbers, CN = www.example.org
DNS:www.example.org, DNS:example.com, DNS:example.edu, DNS:example.net, DNS:example.org, DNS:www.example.com, DNS:www.example.edu, DNS:www.example.net
</code></pre>
<h3 id="_24">工具</h3>
<ul>
<li><code>nslookup</code>DNS 查找工具，例如<code>dig</code>和类似的工具。</li>
<li>搜索引擎（Google、Bing 和其他主要搜索引擎）。</li>
<li>专门的 DNS 相关的基于 Web 的搜索服务：见正文。</li>
<li><a href="https://nmap.org/">地图</a></li>
<li><a href="https://www.tenable.com/products/nessus">Nessus 漏洞扫描程序</a></li>
<li><a href="https://www.cirt.net/nikto2">尼克托</a></li>
</ul>
<h2 id="_25">审查源码</h2>
<p>https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/05-Review_Webpage_Content_for_Information_Leakage</p>
<h3 id="_26">概括</h3>
<p>程序员在他们的源代码中包含详细的注释和元数据是很常见的，甚至是被推荐的。但是，HTML 代码中包含的注释和元数据可能会泄露潜在攻击者不应获得的内部信息。应该进行评论和元数据审查以确定是否有任何信息被泄露。此外，某些应用程序可能会在重定向响应正文中泄露信息。</p>
<p>对于现代网络应用程序，前端使用客户端 JavaScript 变得越来越流行。流行的前端构建技术使用客户端 JavaScript，如 ReactJS、AngularJS 或 Vue。与 HTML 代码中的注释和元数据类似，许多程序员也将敏感信息硬编码在前端的 JavaScript 变量中。敏感信息可以包括（但不限于）：私有 API 密钥（_例如_不受限制的 Google Map API 密钥）、内部 IP 地址、敏感路由（_例如_到隐藏管理页面或功能的路由），甚至凭据。这些敏感信息可能会从此类前端 JavaScript 代码中泄露。应进行审查，以确定是否有任何敏感信息泄露，可能被攻击者滥用。</p>
<p>对于大型网络应用程序，性能问题是程序员非常关心的问题。程序员使用了不同的方法来优化前端性能，包括 Syntactically Awesome Style Sheets (SASS)、Sassy CSS (SCSS)、webpack 等。使用这些技术，前端代码有时会变得更难理解和难以调试，正因为如此，程序员经常部署源映射文件以进行调试。“源地图”是一种特殊文件，它将资产（CSS 或 JavaScript）的缩小/丑化版本连接到原始创作版本。程序员仍在争论是否将源映射文件带到生产环境中。但是，不可否认的是，如果将源映射文件或用于调试的文件发布到生产环境中，将使它们的源代码更具可读性。它可以使攻击者更容易从前端发现漏洞或从中收集敏感信息。应该进行 JavaScript 代码审查以确定是否有任何调试文件从前端公开。根据项目的上下文和敏感性，安全专家应决定文件是否应存在于生产环境中。</p>
<h3 id="_27">测试目标</h3>
<ul>
<li>查看网页评论、元数据和重定向正文以发现任何信息泄漏。</li>
<li>收集 JavaScript 文件并查看 JS 代码，以更好地了解应用程序并查找任何信息泄漏。</li>
<li>确定源映射文件或其他前端调试文件是否存在。</li>
</ul>
<h3 id="_28">如何测试</h3>
<h4 id="_29">查看网页评论和元数据</h4>
<p>开发人员经常使用 HTML 注释来包含有关应用程序的调试信息。有时，他们会忘记评论并将其留在生产环境中。测试人员应该寻找以 开头的 HTML 注释<code>&lt;!--</code>。</p>
<p>检查 HTML 源代码中包含敏感信息的注释，这些信息可以帮助攻击者更深入地了解应用程序。它可能是 SQL 代码、用户名和密码、内部 IP 地址或调试信息。</p>
<pre><code>...
&lt;div class=&quot;table2&quot;&gt;
  &lt;div class=&quot;col1&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;col2&quot;&gt;Mary&lt;/div&gt;
  &lt;div class=&quot;col1&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;col2&quot;&gt;Peter&lt;/div&gt;
  &lt;div class=&quot;col1&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;col2&quot;&gt;Joe&lt;/div&gt;

&lt;!-- Query: SELECT id, name FROM app.users WHERE active='1' --&gt;

&lt;/div&gt;
...
</code></pre>
<p>测试人员甚至可能会发现这样的东西：</p>
<pre><code>&lt;!-- Use the DB administrator password for testing:  f@keP@a$$w0rD --&gt;
</code></pre>
<p>检查 HTML 版本信息以获取有效的版本号和数据类型定义 (DTD) URL</p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
</code></pre>
<ul>
<li><code>strict.dtd</code>– 默认严格 DTD</li>
<li><code>loose.dtd</code>– 宽松的 DTD</li>
<li><code>frameset.dtd</code>– 框架集文档的 DTD</li>
</ul>
<p>有些<code>META</code>标签不提供主动攻击向量，而是允许攻击者分析应用程序：</p>
<pre><code>&lt;META name=&quot;Author&quot; content=&quot;Andrew Muller&quot;&gt;
</code></pre>
<p>一个常见的（但不符合<a href="https://www.w3.org/WAI/standards-guidelines/wcag/">WCAG</a>）<code>META</code>标签是<a href="https://en.wikipedia.org/wiki/Meta_refresh">Refresh</a>。</p>
<pre><code>&lt;META http-equiv=&quot;Refresh&quot; content=&quot;15;URL=https://www.owasp.org/index.html&quot;&gt;
</code></pre>
<p>标签的一个常见用途<code>META</code>是指定搜索引擎可以用来提高搜索结果质量的关键字。</p>
<pre><code>&lt;META name=&quot;keywords&quot; lang=&quot;en-us&quot; content=&quot;OWASP, security, sunshine, lollipops&quot;&gt;
</code></pre>
<p>虽然大多数网络服务器通过文件来管理搜索引擎索引<code>robots.txt</code>，但也可以通过<code>META</code>标签来管理。下面的标签将建议机器人不要编制索引，也不要跟踪包含该标签的 HTML 页面上的链接。</p>
<pre><code>&lt;META name=&quot;robots&quot; content=&quot;none&quot;&gt;
</code></pre>
<p>互联网内容<a href="https://www.w3.org/PICS/">选择平台 (PICS)</a>和<a href="https://www.w3.org/2007/powder/">网络描述资源协议 (POWDER)</a>提供了将元数据与互联网内容相关联的基础设施。</p>
<h4 id="javascript-javascript">识别 JavaScript 代码并收集 JavaScript 文件</h4>
<p>程序员经常在前端使用 JavaScript 变量对敏感信息进行硬编码。<code>&lt;script&gt;</code>测试人员应该检查 HTML 源代码并在和标记之间寻找 JavaScript 代码<code>&lt;/script&gt;</code>。测试人员还应该识别外部 JavaScript 文件以审查代码（JavaScript 文件的文件扩展名<code>.js</code>和 JavaScript 文件的名称通常放在标签的<code>src</code>(source) 属性中）。<code>&lt;script&gt;</code></p>
<p>检查 JavaScript 代码是否存在任何敏感信息泄漏，攻击者可以利用这些信息进一步滥用或操纵系统。查找以下值：API 密钥、内部 IP 地址、敏感路由或凭据。例如：</p>
<pre><code>const myS3Credentials = {
  accessKeyId: config('AWSS3AccessKeyID'),
  secretAcccessKey: config('AWSS3SecretAccessKey'),
};
</code></pre>
<p>测试人员甚至可能会发现这样的东西：</p>
<pre><code>var conString = &quot;tcp://postgres:1234@localhost/postgres&quot;;
</code></pre>
<p>找到 API 密钥后，测试人员可以检查 API 密钥限制是按服务设置的，还是按 IP、HTTP 引荐来源网址、应用程序、SDK 等设置的。</p>
<p>例如，如果测试人员找到 Google Map API 密钥，他们可以检查此 API 密钥是受 IP 限制还是仅受 Google Map API 限制。如果 Google API Key 仅根据 Google Map API 受到限制，攻击者仍然可以使用该 API Key 查询不受限制的 Google Map API，应用程序所有者必须为此付费。</p>
<pre><code>
&lt;script type=&quot;application/json&quot;&gt;
...
{&quot;GOOGLE_MAP_API_KEY&quot;:&quot;AIzaSyDUEBnKgwiqMNpDplT6ozE4Z0XxuAbqDi4&quot;, &quot;RECAPTCHA_KEY&quot;:&quot;6LcPscEUiAAAAHOwwM3fGvIx9rsPYUq62uRhGjJ0&quot;}
...
&lt;/script&gt;
</code></pre>
<p>在某些情况下，测试人员可能会从 JavaScript 代码中找到敏感路径，例如指向内部或隐藏管理页面的链接。</p>
<pre><code>&lt;script type=&quot;application/json&quot;&gt;
...
&quot;runtimeConfig&quot;:{&quot;BASE_URL_VOUCHER_API&quot;:&quot;https://staging-voucher.victim.net/api&quot;, &quot;BASE_BACKOFFICE_API&quot;:&quot;https://10.10.10.2/api&quot;, &quot;ADMIN_PAGE&quot;:&quot;/hidden_administrator&quot;}
...
&lt;/script&gt;
</code></pre>
<h4 id="_30">识别源映射文件</h4>
<p>源映射文件通常会在 DevTools 打开时加载。测试人员还可以通过在每个外部 JavaScript 文件的扩展名后添加“.map”扩展名来查找源映射文件。例如，如果测试人员看到一个<code>/static/js/main.chunk.js</code>文件，他们可以通过访问<code>/static/js/main.chunk.js.map</code>.</p>
<p>检查源映射文件中是否有任何敏感信息可以帮助攻击者更深入地了解应用程序。例如：</p>
<pre><code>{
  &quot;version&quot;: 3,
  &quot;file&quot;: &quot;static/js/main.chunk.js&quot;,
  &quot;sources&quot;: [
    &quot;/home/sysadmin/cashsystem/src/actions/index.js&quot;,
    &quot;/home/sysadmin/cashsystem/src/actions/reportAction.js&quot;,
    &quot;/home/sysadmin/cashsystem/src/actions/cashoutAction.js&quot;,
    &quot;/home/sysadmin/cashsystem/src/actions/userAction.js&quot;,
    &quot;...&quot;
  ],
  &quot;...&quot;
}
</code></pre>
<p>当网站加载源映射文件时，前端源代码将变得可读且更易于调试。</p>
<h4 id="_31">识别泄漏信息的重定向响应</h4>
<p>尽管重定向响应通常不会包含任何重要的 Web 内容，但不能保证它们不会包含任何内容。因此，虽然 300 系列（重定向）响应通常包含“重定向到<code>https://example.com/</code>”类型的内容，但它们也可能会泄露内容。</p>
<p>考虑重定向响应是身份验证或授权检查的结果的情况，如果该检查失败，服务器可能会响应将用户重定向回“安全”或“默认”页面，但重定向响应本身可能仍包含内容它没有在浏览器中显示，但确实传输给了客户端。这可以通过利用浏览器开发人员工具或通过个人代理（例如 ZAP、Burp、Fiddler 或 Charles）来实现。</p>
<h3 id="_32">工具</h3>
<ul>
<li><a href="https://www.gnu.org/software/wget/wget.html">Wget</a></li>
<li>浏览器“查看源代码”功能</li>
<li>眼球</li>
<li><a href="https://curl.haxx.se/">卷曲</a></li>
<li><a href="https://www.zaproxy.org/">Zaproxy</a></li>
<li><a href="https://portswigger.net/burp">打嗝套件</a></li>
<li><a href="https://github.com/tomnomnom/waybackurls">返回网址</a></li>
<li><a href="https://github.com/ozguralp/gmapsapiscanner/">谷歌地图 API 扫描仪</a></li>
</ul>
<h3 id="_33">参考</h3>
<ul>
<li><a href="https://github.com/streaak/keyhacks">钥匙黑客</a></li>
<li><a href="https://ringzer0ctf.com/challenges/104">RingZer0 在线 CTF</a> - 挑战 104 “管理面板”。</li>
</ul>
<h4 id="_34">白皮书</h4>
<ul>
<li><a href="https://www.w3.org/TR/1999/REC-html401-19991224">HTML 版本 4.01</a></li>
<li><a href="https://www.w3.org/TR/2010/REC-xhtml-basic-20101123/">XHTML</a></li>
<li><a href="https://www.w3.org/TR/html5/">HTML 版本 5</a></li>
</ul>
<h2 id="_35">确定应用入口点</h2>
<p>https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/06-Identify_Application_Entry_Points</p>
<h3 id="_36">概括</h3>
<p>在进行任何彻底的测试之前，枚举应用程序及其攻击面是一个关键的先决条件，因为它允许测试人员识别可能的弱点区域。本节旨在帮助识别和映射应用程序中的区域，一旦枚举和映射完成后应进行调查。</p>
<h3 id="_37">测试目标</h3>
<ul>
<li>通过请求和响应分析确定可能的入口和注入点。</li>
</ul>
<h3 id="_38">如何测试</h3>
<p>在开始任何测试之前，测试人员应该始终很好地了解应用程序，以及用户和浏览器如何与之通信。当测试人员遍历应用程序时，他们应该注意所有 HTTP 请求以及传递给应用程序的每个参数和表单字段。他们应特别注意何时使用 GET 请求以及何时使用 POST 请求向应用程序传递参数。此外，他们还需要注意何时使用其他用于 RESTful 服务的方法。</p>
<p>请注意，为了查看在请求正文（例如 POST 请求）中发送的参数，测试人员可能需要使用诸如拦截代理之类的工具（请参阅<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/06-Identify_Application_Entry_Points#tools">工具</a>）。在 POST 请求中，测试人员还应该特别注意传递给应用程序的任何隐藏表单字段，因为这些通常包含敏感信息，例如状态信息、项目数量、项目价格，开发人员永远不会旨在供任何人查看或更改。</p>
<p>根据作者的经验，在这个测试阶段使用拦截代理和电子表格非常有用。代理将在测试人员探索应用程序时跟踪测试人员和应用程序之间的每个请求和响应。此外，在这一点上，测试人员通常会捕获每个请求和响应，以便他们可以准确地看到传递给应用程序的每个标头、参数等以及返回的内容。这有时会非常乏味，尤其是在大型交互式网站上（想想银行应用程序）。然而，经验会告诉我们要寻找什么，这个阶段可以大大减少。</p>
<p>当测试人员遍历应用程序时，他们应该记下 URL、自定义标头或请求/响应正文中的任何有趣参数，并将它们保存在电子表格中。电子表格应包括请求的页面（最好还添加来自代理的请求编号，以供将来参考）、有趣的参数、请求类型（GET、POST 等），如果访问是经过身份验证/未经过身份验证的，如果使用 TLS，如果它是多步骤过程的一部分，如果使用 WebSockets，以及任何其他相关说明。一旦他们规划了应用程序的每个区域，他们就可以检查应用程序并测试他们已经确定的每个区域，并记录哪些有效，哪些无效。本指南的其余部分将确定如何测试每个感兴趣的领域，</p>
<p>以下是所有请求和响应的一些要点。在请求部分，重点关注 GET 和 POST 方法，因为它们出现在大多数请求中。请注意，可以使用其他方法，例如 PUT 和 DELETE。通常，如果允许，这些更罕见的请求可能会暴露漏洞。本指南中有一个专门用于测试这些 HTTP 方法的部分。</p>
<h4 id="_39">要求</h4>
<ul>
<li>确定在何处使用 GET 和在何处使用 POST。</li>
<li>识别 POST 请求中使用的所有参数（这些在请求的正文中）。</li>
<li>在 POST 请求中，请特别注意任何隐藏参数。发送 POST 时，所有表单字段（包括隐藏参数）都将在 HTTP 消息正文中发送到应用程序。这些通常是看不到的，除非使用代理或查看 HTML 源代码。此外，显示的下一页、其数据和访问级别都可能因隐藏参数的值而异。</li>
<li>识别 GET 请求中使用的所有参数（即 URL），特别是查询字符串（通常在 ? 标记之后）。</li>
<li>识别查询字符串的所有参数。这些通常是成对格式，例如<code>foo=bar</code>. 另请注意，许多参数可以在一个查询字符串中，例如由<code>&amp;</code>, <code>\~</code>,<code>:</code>或任何其他特殊字符或编码分隔。</li>
<li>在识别一个字符串或 POST 请求中的多个参数时需要特别注意的是，执行攻击需要部分或全部参数。测试人员需要识别所有参数（即使已编码或加密）并识别哪些参数由应用程序处理。指南的后面部分将确定如何测试这些参数。在这一点上，只需确保它们中的每一个都被识别出来。</li>
<li>还要注意通常看不到的任何其他或自定义类型标头（例如<code>debug: false</code>）。</li>
</ul>
<h4 id="_40">回应</h4>
<ul>
<li>确定新 cookie 的设置（<code>Set-Cookie</code>标头）、修改或添加位置。</li>
<li>确定在正常响应（即未修改的请求）期间存在任何重定向（3xx HTTP 状态代码）、400 状态代码（尤其是 403 Forbidden）和 500 内部服务器错误的位置。</li>
<li>还要注意使用任何有趣的标头的位置。例如，<code>Server: BIG-IP</code>表示该站点是负载平衡的。因此，如果一个站点是负载平衡的并且一台服务器配置不正确，那么测试人员可能不得不发出多个请求来访问易受攻击的服务器，具体取决于所使用的负载平衡类型。</li>
</ul>
<h4 id="owasp">OWASP 攻击面检测器</h4>
<p>Attack Surface Detector (ASD) 工具调查源代码并发现 Web 应用程序的端点、这些端点接受的参数以及这些参数的数据类型。这包括蜘蛛无法找到的未链接端点，或客户端代码中完全未使用的可选参数。它还能够计算应用程序两个版本之间攻击面的变化。</p>
<p>Attack Surface Detector 可作为 ZAP 和 Burp Suite 的插件使用，还提供命令行工具。命令行工具将攻击面导出为 JSON 输出，然后可供 ZAP 和 Burp Suite 插件使用。这对于未直接向渗透测试人员提供源代码的情况很有帮助。例如，渗透测试人员可以从不想提供源代码的客户那里获取 json 输出文件。</p>
<h5 id="_41">如何使用</h5>
<p>CLI jar 文件可从<a href="https://github.com/secdec/attack-surface-detector-cli/releases">https://github.com/secdec/attack-surface-detector-cli/releases</a>下载。</p>
<p>您可以为 ASD 运行以下命令，以从目标 Web 应用程序的源代码中识别端点。</p>
<p><code>java -jar attack-surface-detector-cli-1.3.5.jar &lt;source-code-path&gt; [flags]</code></p>
<p>这是针对<a href="https://github.com/OWASP/railsgoat">OWASP RailsGoat</a>运行命令的示例。</p>
<pre><code>$ java -jar attack-surface-detector-cli-1.3.5.jar railsgoat/
Beginning endpoint detection for '&lt;...&gt;/railsgoat' with 1 framework types
Using framework=RAILS
[0] GET: /login (0 variants): PARAMETERS={url=name=url, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/sessions_contro
ller.rb (lines '6'-'9')
[1] GET: /logout (0 variants): PARAMETERS={}; FILE=/app/controllers/sessions_controller.rb (lines '33'-'37')
[2] POST: /forgot_password (0 variants): PARAMETERS={email=name=email, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/
password_resets_controller.rb (lines '29'-'38')
[3] GET: /password_resets (0 variants): PARAMETERS={token=name=token, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/p
assword_resets_controller.rb (lines '19'-'27')
[4] POST: /password_resets (0 variants): PARAMETERS={password=name=password, paramType=QUERY_STRING, dataType=STRING, user=name=user, paramType=QUERY_STRING, dataType=STRING, confirm_password=name=confirm_password, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/password_resets_controller.rb (lines '5'-'17')
[5] GET: /sessions/new (0 variants): PARAMETERS={url=name=url, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/sessions_controller.rb (lines '6'-'9')
[6] POST: /sessions (0 variants): PARAMETERS={password=name=password, paramType=QUERY_STRING, dataType=STRING, user_id=name=user_id, paramType=SESSION, dataType=STRING, remember_me=name=remember_me, paramType=QUERY_STRING, dataType=STRING, url=name=url, paramType=QUERY_STRING, dataType=STRING, email=name=email, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/sessions_controller.rb (lines '11'-'31')
[7] DELETE: /sessions/{id} (0 variants): PARAMETERS={}; FILE=/app/controllers/sessions_controller.rb (lines '33'-'37')
[8] GET: /users (0 variants): PARAMETERS={}; FILE=/app/controllers/api/v1/users_controller.rb (lines '9'-'11')
[9] GET: /users/{id} (0 variants): PARAMETERS={}; FILE=/app/controllers/api/v1/users_controller.rb (lines '13'-'15')
... snipped ...
[38] GET: /api/v1/mobile/{id} (0 variants): PARAMETERS={id=name=id, paramType=QUERY_STRING, dataType=STRING, class=name=class, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/api/v1/mobile_controller.rb (lines '8'-'13')
[39] GET: / (0 variants): PARAMETERS={url=name=url, paramType=QUERY_STRING, dataType=STRING}; FILE=/app/controllers/sessions_controller.rb (lines '6'-'9')
Generated 40 distinct endpoints with 0 variants for a total of 40 endpoints
Successfully validated serialization for these endpoints
0 endpoints were missing code start line
0 endpoints were missing code end line
0 endpoints had the same code start and end line
Generated 36 distinct parameters
Generated 36 total parameters
- 36/36 have their data type
- 0/36 have a list of accepted values
- 36/36 have their parameter type
--- QUERY_STRING: 35
--- SESSION: 1
Finished endpoint detection for '&lt;...&gt;/railsgoat'
----------
-- DONE --
0 projects had duplicate endpoints
Generated 40 distinct endpoints
Generated 40 total endpoints
Generated 36 distinct parameters
Generated 36 total parameters
1/1 projects had endpoints generated
To enable logging include the -debug argument
</code></pre>
<p>您还可以使用<code>-json</code>标志生成一个 JSON 输出文件，插件可以将其用于 ZAP 和 Burp Suite。有关详细信息，请参阅以下链接。</p>
<ul>
<li><a href="https://github.com/secdec/attack-surface-detector-zap/wiki">OWASP ZAP 的 ASD 插件主页</a></li>
<li><a href="https://github.com/secdec/attack-surface-detector-burp/wiki">PortSwigger Burp 的 ASD 插件主页</a></li>
</ul>
<h4 id="_42">测试应用程序入口点</h4>
<p>以下是有关如何检查应用程序入口点的两个示例。</p>
<h5 id="1">示例 1</h5>
<p>此示例显示了一个 GET 请求，该请求将从在线购物应用程序中购买商品。</p>
<pre><code>GET /shoppingApp/buyme.asp?CUSTOMERID=100&amp;ITEM=z101a&amp;PRICE=62.50&amp;IP=x.x.x.x HTTP/1.1
Host: x.x.x.x
Cookie: SESSIONID=Z29vZCBqb2IgcGFkYXdhIG15IHVzZXJuYW1lIGlzIGZvbyBhbmQgcGFzc3dvcmQgaXMgYmFy
</code></pre>
<blockquote>
<p>请求的所有参数，如 CUSTOMERID、ITEM、PRICE、IP 和 Cookie，这些参数可以只是编码参数或用于会话状态的参数。</p>
</blockquote>
<h5 id="2">示例 2</h5>
<p>此示例显示了一个 POST 请求，该请求将使您登录到应用程序。</p>
<pre><code>POST /example/authenticate.asp?service=login HTTP/1.1
Host: x.x.x.x
Cookie: SESSIONID=dGhpcyBpcyBhIGJhZCBhcHAgdGhhdCBzZXRzIHByZWRpY3RhYmxlIGNvb2tpZXMgYW5kIG1pbmUgaXMgMTIzNA==;CustomCookie=00my00trusted00ip00is00x.x.x.x00

user=admin&amp;pass=pass123&amp;debug=true&amp;fromtrustIP=true
</code></pre>
<p>可以注意到参数在几个位置发送：</p>
<ol>
<li>在查询字符串中：<code>service</code></li>
<li>在 Cookie 标头中：<code>SESSIONID</code>,<code>CustomCookie</code></li>
<li>在请求正文中：<code>user</code>, <code>pass</code>, <code>debug</code>,<code>fromtrustIP</code></li>
</ol>
<p>拥有各种注入位置为攻击者提供了链接的可能性，可以提高在处理代码中发现错误的机会。</p>
<h3 id="_43">工具</h3>
<ul>
<li><a href="https://www.zaproxy.org/">OWASP Zed 攻击代理 (ZAP)</a></li>
<li><a href="https://www.portswigger.net/burp/">打嗝套房</a></li>
<li><a href="https://www.telerik.com/fiddler">提琴手</a></li>
</ul>
<h3 id="_44">参考</h3>
<ul>
<li><a href="https://tools.ietf.org/html/rfc2616">RFC 2616 – 超文本传输​​协议 – HTTP 1.1</a></li>
<li><a href="https://owasp.org/www-project-attack-surface-detector/">OWASP 攻击面检测器</a></li>
</ul>
<h2 id="_45">通过应用映射执行路径</h2>
<p>https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/07-Map_Execution_Paths_Through_Application</p>
<h3 id="_46">概括</h3>
<p>在开始安全测试之前，了解应用程序的结构至关重要。如果对应用程序的布局没有透彻的了解，就不可能对其进行彻底的测试。</p>
<h3 id="_47">测试目标</h3>
<ul>
<li>映射目标应用程序并了解主要工作流。</li>
</ul>
<h3 id="_48">如何测试</h3>
<p>在黑盒测试中，测试整个代码库是极其困难的。不仅仅是因为测试人员看不到应用程序的代码路径，而且即使他们看到了，测试所有代码路径也会非常耗时。协调这一点的一种方法是记录发现和测试的代码路径。</p>
<p>有几种方法可以测试和测量代码覆盖率：</p>
<ul>
<li><strong>PATH</strong> -  测试通过应用程序的每条路径，包括针对每条决策路径的组合和边界值分析测试。虽然这种方法提供了彻底性，但可测试路径的数量随着每个决策分支呈指数增长。</li>
<li><strong>Data Flow (or Taint Analysis)</strong> - 通过外部交互（通常是用户）测试变量的分配。专注于映射整个应用程序中数据的流动、转换和使用。</li>
<li><strong>Race</strong> - 测试处理相同数据的应用程序的多个并发实例。</li>
</ul>
<p>应与应用程序所有者协商权衡使用何种方法以及每种方法的使用程度。也可以采用更简单的方法，包括询问应用程序所有者他们特别关注哪些功能或代码段以及如何到达这些代码段。</p>
<p>为了向应用程序所有者展示代码覆盖率，测试人员可以从电子表格开始并记录通过爬取应用程序（手动或自动）发现的所有链接。然后，测试人员可以更仔细地查看应用程序中的决策点，并调查发现了多少重要的代码路径。然后应将这些记录在电子表格中，其中包含所发现路径的 URL、散文和屏幕截图描述。</p>
<h4 id="_49">自动抓取</h4>
<p>自动蜘蛛是一种用于自动发现特定网站上的新资源（URL）的工具。它以要访问的 URL 列表开始，称为种子，这取决于 Spider 的启动方式。虽然有很多 Spidering 工具，但以下示例使用<a href="https://github.com/zaproxy/zaproxy">Zed Attack Proxy (ZAP)</a>：</p>
<p><img alt="Zed 攻击代理屏幕" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/OWASPZAPSP.png" /><br />
<em>图 4.1.7-1：Zed 攻击代理屏幕</em></p>
<p><a href="https://github.com/zaproxy/zaproxy">ZAP</a>提供各种自动爬取选项，可以根据测试人员的需要加以利用：</p>
<ul>
<li><a href="https://www.zaproxy.org/docs/desktop/start/features/spider/">蜘蛛</a></li>
<li><a href="https://www.zaproxy.org/docs/desktop/addons/ajax-spider/">AJAX蜘蛛</a></li>
<li><a href="https://www.zaproxy.org/docs/desktop/addons/openapi-support/">OpenAPI 支持</a></li>
</ul>
<h3 id="_50">工具</h3>
<ul>
<li><a href="https://github.com/zaproxy/zaproxy">Zed 攻击代理 (ZAP)</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_spreadsheet_software">电子表格软件列表</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_concept-_and_mind-mapping_software">绘图软件</a></li>
</ul>
<h3 id="_51">参考</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Code_coverage">代码覆盖率</a></li>
</ul>
<h2 id="web_1">WEB应用指纹识别</h2>
<p>https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/08-Fingerprint_Web_Application_Framework</p>
<h3 id="_52">概括</h3>
<p>太阳底下没有新鲜事，人们可能想到要开发的几乎所有 Web 应用程序都已经开发出来了。随着世界各地积极开发和部署的大量免费和开源软件项目，应用程序安全测试很可能会面临一个完全或部分依赖于这些众所周知的应用程序或框架（例如 WordPress 、phpBB、Mediawiki 等）。了解正在测试的 Web 应用程序组件对测试过程有很大帮​​助，也将大大减少测试期间所需的工作量。这些众所周知的 Web 应用程序具有众所周知的 HTML 标头、cookie 和目录结构，可以通过枚举来识别这些应用程序。大多数 Web 框架在这些位置都有几个标记，可以帮助攻击者或测试者识别它们。这基本上是所有自动工具所做的，它们从预定义的位置寻找标记，然后将其与已知签名的数据库进行比较。为了获得更好的准确性，通常使用多个标记。</p>
<h3 id="_53">测试目标</h3>
<ul>
<li>对 Web 应用程序使用的组件进行指纹识别。</li>
</ul>
<h3 id="_54">如何测试</h3>
<h4 id="_55">黑盒测试</h4>
<p>为了识别框架或组件，需要考虑几个常见的位置：</p>
<ul>
<li>HTTP 标头</li>
<li>饼干</li>
<li>网页源代码</li>
<li>特定文件和文件夹</li>
<li>文件扩展名</li>
<li>错误讯息</li>
</ul>
<h5 id="http">HTTP 标头</h5>
<p>识别 Web 框架的最基本形式是查看<code>X-Powered-By</code>HTTP 响应标头中的字段。许多工具都可以用来对目标进行指纹识别，最简单的是netcat。</p>
<p>考虑以下 HTTP 请求-响应：</p>
<pre><code>$ nc 127.0.0.1 80
HEAD / HTTP/1.0

HTTP/1.1 200 OK
Server: nginx/1.0.14
[...]
X-Powered-By: Mono
</code></pre>
<p>从<code>X-Powered-By</code>现场，我们了解到 Web 应用程序框架很可能是<code>Mono</code>. 然而，虽然这种方法简单快捷，但这种方法并不是在 100% 的情况下都有效。<code>X-Powered-By</code>可以通过适当的配置轻松禁用标头。还有几种技术可以让网站混淆 HTTP 标头（请参阅<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/08-Fingerprint_Web_Application_Framework#remediation">修复</a>部分中的示例）。<code>nginx</code>在上面的示例中，我们还可以注意到正在使用的特定版本来提供内容。</p>
<p>因此，在同一个示例中，测试人员可能会错过<code>X-Powered-By</code>标头或获得如下所示的答案：</p>
<pre><code>HTTP/1.1 200 OK
Server: nginx/1.0.14
Date: Sat, 07 Sep 2013 08:19:15 GMT
Content-Type: text/html;charset=ISO-8859-1
Connection: close
Vary: Accept-Encoding
X-Powered-By: Blood, sweat and tears
</code></pre>
<p>有时会有更多的 HTTP 标头指向某个框架。在下面的例子中，根据 HTTP 请求的信息，可以看到<code>X-Powered-By</code>header 中包含 PHP 版本。然而，<code>X-Generator</code>标头指出使用的框架实际上是<code>Swiftlet</code>，这有助于渗透测试人员扩展他们的攻击向量。执行指纹识别时，请仔细检查每个 HTTP 标头是否存在此类泄漏。</p>
<pre><code>HTTP/1.1 200 OK
Server: nginx/1.4.1
Date: Sat, 07 Sep 2013 09:22:52 GMT
Content-Type: text/html
Connection: keep-alive
Vary: Accept-Encoding
X-Powered-By: PHP/5.4.16-1~dotdeb.1
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
Pragma: no-cache
X-Generator: Swiftlet
</code></pre>
<h5 id="cookie">Cookie</h5>
<p>确定当前 Web 框架的另一种类似且更可靠的方法是特定于框架的 cookie。</p>
<p>考虑以下 HTTP 请求：</p>
<p><img alt="Cakephp HTTP 请求" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/Cakephp_cookie.png" /><br />
<em>图 4.1.8-7：Cakephp HTTP 请求</em></p>
<p>cookie<code>CAKEPHP</code>已自动设置，它提供有关正在使用的框架的信息。<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/08-Fingerprint_Web_Application_Framework#cookies">Cookie</a>部分列出了常见的 cookie 名称。依赖这种识别机制仍然存在局限性——可以更改 cookie 的名称。例如，对于选定的<code>CakePHP</code>框架，这可以通过以下配置完成（摘自<code>core.php</code>）：</p>
<pre><code>/**
* The name of CakePHP's session cookie.
*
* Note the guidelines for Session names states: &quot;The session name references
* the session id in cookies and URLs. It should contain only alphanumeric
* characters.&quot;
* @link http://php.net/session_name
*/
Configure::write('Session.cookie', 'CAKEPHP');
</code></pre>
<p>但是，与标头的更改相比，进行这些更改的可能性较小<code>X-Powered-By</code>，因此可以认为这种识别方法更可靠。</p>
<h5 id="html">HTML 源代码</h5>
<p>此技术基于在 HTML 页面源代码中查找某些模式。人们通常可以找到很多信息来帮助测试人员识别特定组件。一种常见的标记是直接导致框架泄露的 HTML 注释。通常可以找到某些特定于框架的路径，即指向特定于框架的 CSS 或 JS 文件夹的链接。最后，特定的脚本变量也可能指向某个框架。</p>
<p>从下面的屏幕截图中，可以通过提到的标记轻松了解使用的框架及其版本。注释、具体路径和脚本变量都可以帮助攻击者快速确定ZK框架的实例。</p>
<p><img alt="ZK 框架示例" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/Zk_html_source.png" /><br />
<em>图 4.1.8-2：ZK 框架 HTML 源代码示例</em></p>
<p>此类信息通常位于<code>&lt;head&gt;</code>HTTP 响应部分、<code>&lt;meta&gt;</code>标记中或页面末尾。然而，应该分析整个响应，因为它可以用于其他目的，例如检查其他有用的评论和隐藏字段。有时，Web 开发人员不太关心隐藏有关所用框架或组件的信息。仍然有可能在页面底部偶然发现类似这样的内容：</p>
<p><img alt="女妖底页" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/Banshee_bottom_page.png" /><br />
<em>图 4.1.8-3：Banshee 底部页面</em></p>
<h4 id="_56">特定文件和文件夹</h4>
<p>还有另一种方法可以极大地帮助攻击者或测试者高精度地识别应用程序或组件。每个 Web 组件在服务器上都有自己特定的文件和文件夹结构。已经注意到，可以从 HTML 页面源代码中看到特定路径，但有时它们并没有明确地显示在那里，而是仍然驻留在服务器上。</p>
<p>为了发现它们，使用了一种称为强制浏览或“dirbusting”的技术。Dirbusting 是暴力破解具有已知文件夹和文件名的目标，并监视 HTTP 响应以枚举服务器内容。此信息既可用于查找默认文件和攻击它们，也可用于对 Web 应用程序进行指纹识别。Dirbusting 可以通过多种方式完成，下面的示例显示了在 Burp Suite 的定义列表和入侵者功能的帮助下，对 WordPress 支持的目标进行成功的 dirbusting 攻击。</p>
<p><img alt="使用 Burp 进行清理" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/Wordpress_dirbusting.png" /><br />
<em>图 4.1.8-4：使用 Burp 进行分发</em></p>
<p>我们可以看到，对于某些特定于 WordPress 的文件夹（例如，<code>/wp-includes/</code>和<code>/wp-admin/</code>） ， <code>/wp-content/</code>HTTP 响应分别为 403（禁止访问）、302（找到，重定向到 <code>wp-login.php</code>）和 200（确定）。这是一个很好的指标，表明目标是由 WordPress 驱动的。以同样的方式可以 dirbust 不同的应用程序插件文件夹及其版本。在下面的屏幕截图中，可以看到一个典型的 Drupal 插件的 CHANGELOG 文件，它提供了有关正在使用的应用程序的信息，并揭示了一个易受攻击的插件版本。</p>
<p><img alt="Drupal Botcha 披露" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/Drupal_botcha_disclosure.png" /><br />
<em>图 4.1.8-5：Drupal Botcha 披露</em></p>
<p>提示：在开始 dirbusting 之前，请先检查<code>robots.txt</code>文件。有时也可以在那里找到特定于应用程序的文件夹和其他敏感信息。<code>robots.txt</code>下面的屏幕截图显示了此类文件的示例。</p>
<p><img alt="机器人信息公开" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/Robots-info-disclosure.png" /><br />
<em>图 4.1.8-6：机器人信息公开</em></p>
<p>每个特定应用程序的特定文件和文件夹都不同。如果确定的应用程序或组件是开源的，则在渗透测试期间设置临时安装可能有价值，以便更好地了解所提供的基础设施或功能，以及服务器上可能留下的文件。但是，已经存在几个不错的文件列表；一个很好的例子是<a href="https://github.com/fuzzdb-project/fuzzdb">可预测文件/文件夹的 FuzzDB 词表</a>。</p>
<h5 id="_57">文件扩展名</h5>
<p>URL 可能包含文件扩展名，这也有助于识别网络平台或技术。</p>
<p>例如，OWASP wiki 使用 PHP：</p>
<pre><code>https://wiki.owasp.org/index.php?title=Fingerprint_Web_Application_Framework&amp;action=edit&amp;section=4
</code></pre>
<p>以下是一些常见的 Web 文件扩展名和相关技术：</p>
<ul>
<li><code>.php</code>– PHP</li>
<li><code>.aspx</code>– 微软 ASP.NET</li>
<li><code>.jsp</code>– Java 服务器页面</li>
</ul>
<h5 id="_58">错误信息</h5>
<p>如以下屏幕截图所示，列出的文件系统路径指向使用 WordPress ( <code>wp-content</code>)。测试人员还应该知道 WordPress 是基于 PHP 的 ( <code>functions.php</code>)。</p>
<p><img alt="WordPress 解析错误" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/wp-syntaxerror.png" /><br />
<em>图 4.1.8-7：WordPress 解析错误</em></p>
<h3 id="_59">通用标识符</h3>
<h4 id="cookie_1">Cookie</h4>
<p>Framework Cookie name</p>
<p>Zope zope3</p>
<p>CakePHP cakephp</p>
<p>Kohana kohanasession</p>
<p>Laravel laravel_session</p>
<p>phpBB phpbb3_</p>
<p>WordPress wp-settings</p>
<p>1C-Bitrix BITRIX_</p>
<p>AMPcms AMP</p>
<p>Django CMS django</p>
<p>DotNetNuke DotNetNukeAnonymous</p>
<p>e107 e107_tz</p>
<p>EPiServer EPiTrace, EPiServer</p>
<p>Graffiti CMS graffitibot</p>
<p>Hotaru CMS hotaru_mobile</p>
<p>ImpressCMS ICMSession</p>
<p>Indico MAKACSESSION</p>
<p>InstantCMS InstantCMS[logdate]</p>
<p>Kentico CMS CMSPreferredCulture</p>
<p>MODx SN4[12symb]</p>
<p>TYPO3 fe_typo_user</p>
<p>Dynamicweb Dynamicweb</p>
<p>LEPTON lep[some_numeric_value]+sessionid</p>
<p>Wix Domain=.wix.com</p>
<p>VIVVO VivvoSessionId</p>
<h4 id="html_1">HTML 源代码</h4>
<p>应用</p>
<p>关键词</p>
<p>WordPress的</p>
<p><code>&lt;meta name="generator" content="WordPress 3.9.2" /&gt;</code></p>
<p>phpBB</p>
<p><code>&lt;body id="phpbb"</code></p>
<p>Mediawiki</p>
<p><code>&lt;meta name="generator" content="MediaWiki 1.21.9" /&gt;</code></p>
<p>Joomla</p>
<p><code>&lt;meta name="generator" content="Joomla! - Open Source Content Management" /&gt;</code></p>
<p>Drupal</p>
<p><code>&lt;meta name="Generator" content="Drupal 7 (http://drupal.org)" /&gt;</code></p>
<p>DotNetNuke</p>
<p><code>DNN Platform - [http://www.dnnsoftware.com](http://www.dnnsoftware.com)</code></p>
<h5 id="_60">一般标记</h5>
<ul>
<li><code>%framework_name%</code></li>
<li><code>powered by</code></li>
<li><code>built upon</code></li>
<li><code>running</code></li>
</ul>
<h5 id="_61">特定标记</h5>
<p>框架</p>
<p>关键词</p>
<p>Adobe ColdFusion</p>
<p><code>&lt;!-- START headerTags.cfm</code></p>
<p>Microsoft ASP.NET</p>
<p><code>__VIEWSTATE</code></p>
<p>ZK</p>
<p><code>&lt;!-- ZK</code></p>
<p>Business Catalyst</p>
<p><code>&lt;!-- BC_OBNW --&gt;</code></p>
<p>Indexhibit</p>
<p><code>ndxz-studio</code></p>
<h3 id="_62">整治</h3>
<p>虽然可以努力使用不同的 cookie 名称（通过更改配置）、隐藏或更改文件/目录路径（通过重写或源代码更改）、删除已知标头等，但这些努力归结为“通过模糊实现安全”。系统所有者/管理员应该认识到，这些努力只会减慢最基本的对手。时间/精力可以更好地用于利益相关者意识和解决方案维护活动。</p>
<h3 id="_63">工具</h3>
<p>下面列出了常用和众所周知的工具。还有很多其他实用程序，以及基于框架的指纹识别工具。</p>
<h4 id="whatweb">Whatweb</h4>
<p>网站：<a href="https://github.com/urbanadventurer/WhatWeb">https ://github.com/urbanadventurer/WhatWeb</a></p>
<p>目前市场上最好的指纹识别工具之一。包含在默认的<a href="https://www.kali.org/">Kali Linux</a>构建中。语言：Ruby 用于指纹识别的匹配使用：</p>
<ul>
<li>文本字符串（区分大小写）</li>
<li>常用表达</li>
<li>Google Hack 数据库查询（有限的关键字集）</li>
<li>MD5 哈希</li>
<li>网址识别</li>
<li>HTML 标记模式</li>
<li>用于被动和主动操作的自定义 ruby​​ 代码</li>
</ul>
<p>示例输出显示在下面的屏幕截图中：</p>
<p><img alt="Whatweb 输出示例" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/Whatweb-sample.png" /><br />
<em>图 4.1.8-8：Whatweb 输出示例</em></p>
<h4 id="wappalyzer">Wappalyzer</h4>
<p>网站：<a href="https://www.wappalyzer.com/">https ://www.wappalyzer.com/</a></p>
<p>Wappalyzer 有多种使用模式，其中最流行的可能是 Firefox/Chrome 扩展。它们仅适用于正则表达式匹配，除了要在浏览器中加载的页面外，不需要任何其他内容。它完全在浏览器级别工作，并以图标的形式给出结果。虽然有时它会出现误报，但在浏览页面后立即了解使用了哪些技术来构建目标网站非常方便。</p>
<p>下面的屏幕截图显示了插件的示例输出。</p>
<p><img alt="OWASP 网站的 Wappalyzer 输出" src="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/images/Owasp-wappalyzer.png" /><br />
<em>图 4.1.8-9：OWASP 网站的 Wappalyzer 输出</em></p>
<h3 id="_64">参考</h3>
<h4 id="_65">白皮书</h4>
<ul>
<li><a href="https://web.archive.org/web/20190526182734/https://net-square.com/httprint_paper.html">Saumil Shah：“HTTP 指纹识别简介”</a></li>
<li><a href="https://anantshri.info/articles/web_app_finger_printing.html">Anant Shrivastava：“网络应用指纹识别”</a></li>
</ul>
<h2 id="web_2">WEB服务器指纹识别</h2>
<p>https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/02-Fingerprint_Web_Server</p>
<h3 id="_66">概括</h3>
<p>Web 服务器指纹识别是识别运行目标的 Web 服务器的类型和版本的任务。虽然 Web 服务器指纹通常封装在自动化测试工具中，但对于研究人员来说，了解这些工具如何尝试识别软件的基本原理及其有用的原因非常重要。</p>
<p>准确地发现运行应用程序的 Web 服务器的类型可以使安全测试人员确定应用程序是否容易受到攻击。特别是，运行没有最新安全补丁的旧版本软件的服务器可能容易受到已知版本特定漏洞的攻击。</p>
<h3 id="_67">测试目标</h3>
<ul>
<li>确定正在运行的 Web 服务器的版本和类型，以便进一步发现任何已知漏洞。</li>
</ul>
<h3 id="_68">如何测试</h3>
<p>用于 Web 服务器指纹识别的技术包括<a href="https://en.wikipedia.org/wiki/Banner_grabbing">banner抓取</a>、引发对格式错误的请求的响应，以及使用自动化工具执行使用策略组合的更强大的扫描。所有这些技术运作的基本前提是相同的。他们都努力从 Web 服务器中引出一些响应，然后可以将这些响应与已知响应和行为的数据库进行比较，从而与已知的服务器类型相匹配。</p>
<h4 id="banner">banner 抓取</h4>
<p>banner抓取是通过向 Web 服务器发送 HTTP 请求并检查其<a href="https://developer.mozilla.org/en-US/docs/Glossary/Response_header">响应标头来</a>执行的。这可以使用各种工具来完成，包括<code>telnet</code>HTTP 请求或<code>openssl</code>通过 TLS/SSL 的请求。</p>
<p>例如，这是对来自 Apache 服务器的请求的响应。</p>
<pre><code>HTTP/1.1 200 OK
Date: Thu, 05 Sep 2019 17:42:39 GMT
Server: Apache/2.4.41 (Unix)
Last-Modified: Thu, 05 Sep 2019 17:40:42 GMT
ETag: &quot;75-591d1d21b6167&quot;
Accept-Ranges: bytes
Content-Length: 117
Connection: close
Content-Type: text/html
...
</code></pre>
<p>这是另一个响应，这次来自 nginx。</p>
<pre><code>HTTP/1.1 200 OK
Server: nginx/1.17.3
Date: Thu, 05 Sep 2019 17:50:24 GMT
Content-Type: text/html
Content-Length: 117
Last-Modified: Thu, 05 Sep 2019 17:40:42 GMT
Connection: close
ETag: &quot;5d71489a-75&quot;
Accept-Ranges: bytes
...
</code></pre>
<p>这是来自 lighttpd 的响应。</p>
<pre><code>HTTP/1.0 200 OK
Content-Type: text/html
Accept-Ranges: bytes
ETag: &quot;4192788355&quot;
Last-Modified: Thu, 05 Sep 2019 17:40:42 GMT
Content-Length: 117
Connection: close
Date: Thu, 05 Sep 2019 17:57:57 GMT
Server: lighttpd/1.4.54
</code></pre>
<p>在这些例子中，服务器类型和版本被清楚地暴露了。但是，注重安全的应用程序可能会通过修改标头来混淆其服务器信息。例如，以下是对具有修改标头的站点请求的响应的摘录：</p>
<pre><code>HTTP/1.1 200 OK
Server: Website.com
Date: Thu, 05 Sep 2019 17:57:06 GMT
Content-Type: text/html; charset=utf-8
Status: 200 OK
...
</code></pre>
<p>在服务器信息模糊不清的情况下，测试人员可能会根据标头字段的顺序猜测服务器的类型。请注意，在上面的 Apache 示例中，字段遵循以下顺序：</p>
<ul>
<li>日期</li>
<li>服务器</li>
<li>最后修改</li>
<li>电子标签</li>
<li>接受范围</li>
<li>内容长度</li>
<li>联系</li>
<li>内容类型</li>
</ul>
<p>但是，在 nginx 和模糊服务器示例中，共同的字段都遵循以下顺序：</p>
<ul>
<li>服务器</li>
<li>日期</li>
<li>内容类型</li>
</ul>
<p>测试人员可以根据这些信息猜测被遮挡的服务器是nginx。但是，考虑到多个不同的Web服务器可能共享相同的字段顺序并且可以修改或删除字段，这种方法是不确定的。</p>
<h4 id="_69">发送格式错误的请求</h4>
<p>Web 服务器可以通过检查它们的错误响应来识别，并且在它们没有被定制的情况下，它们的默认错误页面。强制服务器呈现这些内容的一种方法是故意发送不正确或格式错误的请求。</p>
<p>例如，这是对<code>SANTA CLAUS</code>来自 Apache 服务器的不存在方法的请求的响应。</p>
<pre><code>GET / SANTA CLAUS/1.1


HTTP/1.1 400 Bad Request
Date: Fri, 06 Sep 2019 19:21:01 GMT
Server: Apache/2.4.41 (Unix)
Content-Length: 226
Connection: close
Content-Type: text/html; charset=iso-8859-1

&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;
&lt;html&gt;&lt;head&gt;
&lt;title&gt;400 Bad Request&lt;/title&gt;
&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;Bad Request&lt;/h1&gt;
&lt;p&gt;Your browser sent a request that this server could not understand.&lt;br /&gt;
&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>这是对来自 nginx 的相同请求的响应。</p>
<pre><code>GET / SANTA CLAUS/1.1


&lt;html&gt;
&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx/1.17.3&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这是对来自 lighttpd 的相同请求的响应。</p>
<pre><code>GET / SANTA CLAUS/1.1


HTTP/1.0 400 Bad Request
Content-Type: text/html
Content-Length: 345
Connection: close
Date: Sun, 08 Sep 2019 21:56:17 GMT
Server: lighttpd/1.4.54

&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;
         &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;
 &lt;head&gt;
  &lt;title&gt;400 Bad Request&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;400 Bad Request&lt;/h1&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>由于默认错误页面在不同类型的 Web 服务器之间提供了许多区分因素，因此即使在服务器标头字段被遮盖的情况下，它们的检查也可以成为指纹识别的有效方法。</p>
<h4 id="_70">使用自动扫描工具</h4>
<p>如前所述，Web 服务器指纹识别通常作为自动扫描工具的一项功能包含在内。这些工具能够发出类似于上面演示的请求，以及发送其他更特定于服务器的探测。自动化工具可以比手动测试更快地比较来自 Web 服务器的响应，并利用已知响应的大型数据库来尝试识别服务器。由于这些原因，自动化工具更有可能产生准确的结果。</p>
<p>以下是一些包含 Web 服务器指纹识别功能的常用扫描工具。</p>
<ul>
<li><a href="https://toolbar.netcraft.com/site_report">Netcraft</a>，一种扫描网站信息（包括网络服务器）的在线工具。</li>
<li><a href="https://github.com/sullo/nikto">Nikto</a>，一种开源命令行扫描工具。</li>
<li><a href="https://nmap.org/">Nmap</a>，一个开源命令行工具，也有一个 GUI，<a href="https://nmap.org/zenmap/">Zenmap</a>。</li>
</ul>
<h3 id="_71">整治</h3>
<p>虽然暴露的服务器信息本身不一定是漏洞，但它是可以帮助攻击者利用可能存在的其他漏洞的信息。暴露的服务器信息还可能导致攻击者找到特定于版本的服务器漏洞，这些漏洞可用于利用未打补丁的服务器。因此，建议采取一些预防措施。这些行动包括：</p>
<ul>
<li>隐藏标头中的 Web 服务器信息，例如使用 Apache 的<a href="https://httpd.apache.org/docs/current/mod/mod_headers.html">mod_headers 模块</a>。</li>
<li>使用加固的<a href="https://en.wikipedia.org/wiki/Proxy_server#Reverse_proxies">反向代理服务器</a>在 Web 服务器和 Internet 之间创建额外的安全层。</li>
<li>确保 Web 服务器与最新的软件和安全补丁保持同步。</li>
</ul>
<h1 id="map">MAP 应用框架</h1>
<p><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/10-Map_Application_Architecture">网页</a></p>
<h2 id="_72">概括</h2>
<p>为了有效地测试应用程序，并能够就如何解决任何已识别的问题提供有意义的建议，了解您实际测试的内容非常重要。此外，它还可以帮助确定是否应将特定组件视为超出测试范围。</p>
<p>现代 Web 应用程序的复杂性可能有很大差异，从在单个服务器上运行的简单脚本到跨数十种不同系统、语言和组件的高度复杂的应用程序。还可能有额外的网络级组件，例如防火墙或入侵保护系统，它们会对测试产生重大影响。</p>
<h2 id="_73">测试目标</h2>
<ul>
<li>了解应用程序的架构和使用的技术。</li>
</ul>
<h2 id="_74">如何测试</h2>
<p>从黑盒角度进行测试时，重要的是要尝试清楚地了解应用程序的工作方式，以及采用了哪些技术和组件。在某些情况下，可以测试特定组件（例如 Web 应用程序防火墙），而其他情况则可以通过检查应用程序的行为来识别。</p>
<p>以下部分提供了对常见架构组件的高级概述，以及如何识别它们的详细信息。</p>
<h3 id="_75">应用组件</h3>
<h4 id="_76">网络服务器</h4>
<p>简单的应用程序可能会在单个服务器上运行，这可以使用指南的<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/02-Fingerprint_Web_Server">指纹 Web 服务器</a>部分中讨论的步骤来识别。</p>
<h4 id="paas">平台即服务 (PaaS)</h4>
<p>在平台即服务 (PaaS) 模型中，Web 服务器和底层基础设施由服务提供商管理，客户只对部署在其上的应用程序负责。从测试的角度来看，有两个主要区别：</p>
<ul>
<li>应用程序所有者无权访问底层基础设施，因此无法直接修复任何问题。</li>
<li>基础设施测试很可能超出任何项目的范围。</li>
</ul>
<p>在某些情况下，可以识别 PaaS 的使用，因为应用程序可能使用特定的域名（例如，部署在 Azure App Services 上的应用程序将有一个<code>*.azurewebsites.net</code>域——尽管它们也可能使用自定义域）。但是，在其他情况下，很难确定是否正在使用 PaaS。</p>
<h4 id="_77">无服务器</h4>
<p>在无服务器模型中，开发人员提供直接在托管平台上作为独立功能运行的代码，而不是作为部署在 webroot 中的传统大型 Web 应用程序。这使得它非常适合基于微服务的架构。与 PaaS 环境一样，基础架构测试可能超出范围。</p>
<p>在某些情况下，可能会通过特定 HTTP 标头的存在来指示无服务器代码的使用。例如，AWS Lambda 函数通常会返回以下标头：</p>
<pre><code>X-Amz-Invocation-Type
X-Amz-Log-Type
X-Amz-Client-Context
</code></pre>
<p>Azure Functions 不太明显。它们通常会返回<code>Server: Kestrel</code>标头 - 但这本身并不足以确信它是一个 Azure 应用程序函数，而不是在 Kestrel 上运行的一些其他代码。</p>
<h4 id="_78">微服务</h4>
<p>在基于微服务的架构中，应用程序 API 由多个离散服务组成，而不是作为一个整体应用程序运行。服务本身通常在容器内运行（通常使用 Kubernetes），并且可以使用各种不同的操作系统和语言。尽管它们通常位于单个 API 网关和域之后，但使用多种语言（通常在详细的错误消息中指出）可能表明正在使用微服务。</p>
<h4 id="_79">静态存储</h4>
<p>许多应用程序将静态内容存储在专用存储平台上，而不是直接托管在主 Web 服务器上。两个最常见的平台是 Amazon 的 S3 Buckets 和 Azure 的 Storage Accounts，可以通过域名轻松识别：</p>
<ul>
<li>Amazon S3 存储桶是<code>BUCKET.s3.amazonaws.com</code>或<code>s3.REGION.amazonaws.com/BUCKET</code></li>
<li>Azure 存储帐户是<code>ACCOUNT.blob.core.windows.net</code></li>
</ul>
<p>这些存储帐户通常会暴露敏感文件，如<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/11-Test_Cloud_Storage">测试云存储指南</a>部分所述。</p>
<h4 id="_80">数据库</h4>
<p>大多数重要的 Web 应用程序使用某种数据库来存储动态内容。在某些情况下，可以确定数据库，尽管它通常依赖于应用程序中的其他问题。这通常可以通过以下方式完成：</p>
<ul>
<li>端口扫描服务器并查找与特定数据库关联的任何开放端口。</li>
<li>触发与 SQL（或 NoSQL）相关的错误消息（或从<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/01-Conduct_Search_Engine_Discovery_Reconnaissance_for_Information_Leakage">搜索引擎</a>中查找现有错误。</li>
</ul>
<p>如果无法最终确定数据库，您通常可以根据应用程序的其他方面进行有根据的猜测：</p>
<ul>
<li>Windows、IIS 和 ASP.NET 经常使用 Microsoft SQL 服务器。</li>
<li>嵌入式系统通常使用 SQLite。</li>
<li>PHP 通常使用 MySQL 或 PostgreSQL。</li>
<li>APEX 经常使用 Oracle。</li>
</ul>
<p>这些不是硬性规定，但如果没有更好的信息，肯定可以为您提供一个合理的起点。</p>
<h4 id="_81">验证</h4>
<p>大多数应用程序都有某种形式的用户身份验证。可以使用多种身份验证后端，例如：</p>
<ul>
<li>Web 服务器配置（包括<code>.htaccess</code>文件）或脚本中的硬编码密码。<ul>
<li>通常显示为 HTTP 基本身份验证，由浏览器中的弹出窗口和<code>WWW-Authenticate: Basic</code>HTTP 标头指示。</li>
</ul>
</li>
<li>数据库中的本地用户帐户。<ul>
<li>通常集成到应用程序的表单或 API 端点中。</li>
</ul>
</li>
<li>现有的中央身份验证源，例如 Active Directory 或 LDAP 服务器。<ul>
<li>可以使用 NTLM 身份验证，由<code>WWW-Authenticate: NTLM</code>HTTP 标头指示。</li>
<li>可以以一种形式集成到 Web 应用程序中。</li>
<li>可能需要以“DOMAIN\username”格式输入用户名，或者可能会提供可用域的下拉列表。</li>
</ul>
</li>
<li>与内部或外部提供商的单点登录 (SSO)。<ul>
<li>通常使用 OAuth、OpenID Connect 或 SAML。</li>
</ul>
</li>
</ul>
<p>应用程序可能会为用户提供多种身份验证选项（例如注册本地帐户或使用他们现有的 Facebook 帐户），并且可能会为普通用户和管理员使用不同的机制。</p>
<h4 id="api">第三方服务和 API</h4>
<p>几乎所有 Web 应用程序都包含由客户端加载或与之交互的第三方资源。这些可以包括：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content#mixed_active_content">活动内容</a>（例如脚本、样式表、字体和 iframe）。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content#mixed_passivedisplay_content">被动内容</a>（例如图像和视频）。</li>
<li>外部 API。</li>
<li>社交媒体按钮。</li>
<li>广告网络。</li>
<li>支付网关。</li>
</ul>
<p>这些资源直接由用户的浏览器请求，因此可以使用开发人员工具或拦截代理轻松识别。虽然识别它们很重要（因为它们会影响应用程序的安全性），但请记住_它们通常不在测试范围内_，因为它们属于第三方。</p>
<h3 id="_82">网络组件</h3>
<h4 id="_83">反向代理</h4>
<p>反向代理位于一个或多个后端服务器之前，并将请求重定向到适当的目的地。它们可以实现各种功能，例如：</p>
<ul>
<li>充当<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/10-Map_Application_Architecture#load-balancer">负载平衡器</a>或<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/10-Map_Application_Architecture#web-application-firewall-waf">Web 应用程序防火墙</a>。</li>
<li>允许多个应用程序托管在单个 IP 地址或域（在子文件夹中）。</li>
<li>实施 IP 过滤或其他限制。</li>
<li>从后端缓存内容以提高性能。</li>
</ul>
<p>并非总能检测到反向代理（特别是如果它后面只有一个应用程序），但有时您通常可以通过以下方式识别它：</p>
<ul>
<li>前端服务器和后端应用程序之间的不匹配（例如<code>Server: nginx</code>带有 ASP.NET 应用程序的标头）。<ul>
<li>这有时会导致<a href="https://portswigger.net/web-security/request-smuggling">请求走私漏洞</a>。</li>
</ul>
</li>
<li>重复的标头（尤其是<code>Server</code>标头）。</li>
<li>在同一 IP 地址或域上托管多个应用程序（尤其是当它们使用不同语言时）。</li>
</ul>
<h4 id="_84">负载均衡器</h4>
<p>负载均衡器位于多个后端服务器之前，并在它们之间分配请求，以便为应用程序提供更大的冗余和处理能力。</p>
<p>负载均衡器可能难以检测，但有时可以通过发出多个请求并检查响应的差异来识别，例如：</p>
<ul>
<li>系统时间不一致。</li>
<li>详细错误消息中的不同内部 IP 地址或主机名。</li>
<li><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery">从服务器端请求伪造 (SSRF)</a>返回的不同地址。</li>
</ul>
<p>它们也可以通过特定 cookie 的存在来指示（例如，F5 BIG-IP 负载平衡器将创建一个名为<code>BIGipServer</code>.</p>
<h4 id="cdn">内容分发网络 (CDN)</h4>
<p>内容分发网络 (CDN) 是一组地理分布的缓存代理服务器，旨在提高网站性能，为网站提供额外的弹性。</p>
<p>它通常通过将面向公众的域指向 CDN 的服务器，然后配置 CDN 以连接到正确的后端服务器（有时称为“源”）来配置。</p>
<p>检测 CDN 的最简单方法是对域解析到的 IP 地址执行 WHOIS 查询。如果他们属于 CDN 公司（例如 Akamai、Cloudflare 或 Fastly - 请参阅<a href="https://en.wikipedia.org/wiki/Content_delivery_network#Notable_content_delivery_service_providers">维基百科</a>以获取更完整的列表），那么就好像正在使用 CDN。</p>
<p>在 CDN 后面测试站点时，您应该牢记以下几点：</p>
<ul>
<li>IP 和服务器属于 CDN 提供商，很可能不在基础设施测试范围内。</li>
<li>许多 CDN 还包括机器人检测、速率限制和 Web 应用程序防火墙等功能。</li>
<li>CDN 通常缓存内容，因此对后端网站所做的任何更改可能不会立即显示。</li>
</ul>
<p>如果该站点位于 CDN 后面，则识别后端服务器会很有用。如果他们没有实施适当的访问控制，那么您可以通过直接访问后端服务器来绕过 CDN（及其提供的任何保护）。有多种不同的方法可以让您识别后端系统：</p>
<ul>
<li>应用程序发送的电子邮件可能直接来自后端服务器，这可能会泄露其 IP 地址。</li>
<li>域的 DNS 研磨、区域传输或证书透明列表可能会在子域上显示它。</li>
<li>扫描公司已知使用的 IP 范围可能会找到后端服务器。</li>
<li>利用<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery">服务器端请求伪造 (SSRF)</a>可能会泄露 IP 地址。</li>
<li>来自应用程序的详细错误消息可能会暴露 IP 地址或主机名。</li>
</ul>
<h3 id="_85">安全组件</h3>
<h4 id="_86">网络防火墙</h4>
<p>大多数 Web 服务器将受到数据包过滤或状态检测防火墙的保护，这些防火墙会阻止任何不需要的网络流量。要检测到这一点，请对服务器执行端口扫描并检查结果。</p>
<p>如果大多数端口显示为“关闭”（即，它们返回一个<code>RST</code>数据包以响应初始<code>SYN</code>数据包），则这表明服务器可能不受防火墙保护。如果端口显示为“已过滤”（即，将数据包发送到未使用的端口时未收到响应<code>SYN</code>），则很可能存在防火墙。</p>
<p>此外，如果向世界公开了不适当的服务（例如 SMTP、IMAP、MySQL 等），这表明要么没有适当的防火墙，要么防火墙配置不当。</p>
<h4 id="_87">网络入侵检测与防御系统</h4>
<p>网络入侵检测系统 (IDS) 检测可疑或恶意的网络级活动（例如端口或漏洞扫描）并发出警报。入侵防御系统 (IPS) 与此类似，但也会采取措施阻止活动 - 通常是通过阻止源 IP 地址。</p>
<p>通常可以通过针对目标运行自动扫描工具（例如端口扫描器）并查看源 IP 是否被阻止来检测 IPS。然而，许多应用程序级工具可能无法被 IPS 检测到（特别是如果它不解密 TLS）。</p>
<h4 id="web-waf">Web 应用程序防火墙 (WAF)</h4>
<p>Web 应用程序防火墙 (WAF) 检查 HTTP 请求的内容并阻止那些看似可疑或恶意的请求，或动态应用其他控制，例如 CAPTCHA 或速率限制。它们通常基于一组已知的错误签名和正则表达式，例如<a href="https://owasp.org/www-project-modsecurity-core-rule-set/">OWASP 核心规则集</a>。WAF 可以有效地防范某些类型的攻击（例如 SQL 注入或跨站点脚本），但对其他类型的攻击（例如访问控制或业务逻辑相关问题）则效果较差。</p>
<p>WAF 可以部署在多个位置，包括：</p>
<ul>
<li>在 Web 服务器本身上。</li>
<li>在单独的虚拟机或硬件设备上。</li>
<li>在后端服务器前面的云端。</li>
</ul>
<p>因为WAF拦截了恶意请求，所以可以通过在参数中加入常见的攻击字符串，观察是否被拦截来检测。例如，尝试添加一个名为或<code>foo</code>之类的参数。如果这些请求被阻止，则表明可能存在 WAF。此外，块页面的内容可以提供有关正在使用的特定技术的信息。最后，某些 WAF 可能会将 cookie 或 HTTP 标头添加到可以显示其存在的响应中。<code>' UNION SELECT 1``&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<p>如果正在使用基于云的 WAF，则可以通过直接访问后端服务器来绕过它，使用<a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/10-Map_Application_Architecture#content-delivery-network-cdn">内容交付网络</a>部分中讨论的相同方法。</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../%E6%A6%82%E8%BF%B0/" class="btn btn-neutral float-left" title="概述"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../2%E3%80%81%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%E7%AE%A1%E7%90%86%E6%B5%8B%E8%AF%95/" class="btn btn-neutral float-right" title="配置部署管理测试">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../%E6%A6%82%E8%BF%B0/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../2%E3%80%81%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%E7%AE%A1%E7%90%86%E6%B5%8B%E8%AF%95/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
